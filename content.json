{"meta":{"title":"skuukzky","subtitle":"眠","description":"","author":"skuukzky","url":"https://lpy30m.github.io/skuukzky.github.io","root":"/skuukzky.github.io/"},"pages":[{"title":"朋友","date":"2024-08-23T04:00:00.000Z","updated":"2024-08-28T06:25:36.036Z","comments":true,"path":"PY.html","permalink":"https://lpy30m.github.io/skuukzky.github.io/PY.html","excerpt":"","text":"今诸生学于太学，县官日有廪稍之供，父母岁有裘葛之遗，无冻馁之患矣；坐大厦之下而诵诗书，无奔走之劳矣；有司业、博士为之师，未有问而不告，求而不得者也；凡所宜有之书，皆集于此，不必若余之手录，假诸人而后见也。其业有不精，德有不成者，非天质之卑，则心不若余之专耳，岂他人之过哉！ 使用网站 朋友每次编译时，随机排序 添加友链你可以直接编辑：https://github.com/nexmoe/nexmoe.com/edit/main/source/PY.md 也可以使用如下格式方便懒狗我复制粘贴 123456{ &quot;title&quot;: &quot;折影轻梦&quot;, &quot;link&quot;: &quot;https://nexmoe.com&quot;, &quot;img&quot;: &quot;https://cravatar.cn/avatar/c7fd185f8c967dec20c29c75a40b9e09?s=500&quot;, &quot;des&quot;: &quot;为热爱战斗着，努力学着变得勇敢&quot; }"},{"title":"关于","date":"2024-08-23T04:14:22.573Z","updated":"2024-08-23T04:14:22.573Z","comments":true,"path":"about.html","permalink":"https://lpy30m.github.io/skuukzky.github.io/about.html","excerpt":"","text":"我是谁导航"},{"title":"文章归档","date":"2024-08-23T04:09:57.710Z","updated":"2024-08-23T04:09:53.839Z","comments":true,"path":"archive.html","permalink":"https://lpy30m.github.io/skuukzky.github.io/archive.html","excerpt":"","text":""},{"title":"","date":"2024-09-27T14:33:32.526Z","updated":"2024-09-27T14:33:32.526Z","comments":true,"path":"custom.css","permalink":"https://lpy30m.github.io/skuukzky.github.io/custom.css","excerpt":"","text":":root { --color-shadow: rgb(204 177 161 / 60%); } body { overflow-x: hidden; } #nexmoe-content .nexmoe-post-footer { background-color: transparent; } iframe { width: 100% !important; } article ul li { line-height: 1.5rem; } [data-theme=\"light\"] { --hl-color: #90a4ae !important; --hl-bg: #f6f8fa !important; --hltools-bg: #e6ebf1 !important; --hltools-color: #90a4ae !important; --hlnumber-bg: #f6f8fa !important; --hlnumber-color: rgba(144, 164, 174, 0.5) !important; --hlscrollbar-bg: #dce4eb !important; --hlexpand-bg: linear-gradient(180deg, rgba(246, 248, 250, 0.1), rgba(246, 248, 250, 0.9)) !important; } [data-theme=\"dark\"] { --hl-color: #abb2bf !important; --hl-bg: #282c34 !important; --hltools-bg: #21252b !important; --hltools-color: #bbbbbc !important; --hlnumber-bg: #282c34 !important; --hlnumber-color: #495162 !important; --hlscrollbar-bg: #373c47 !important; --hlexpand-bg: linear-gradient(180deg, rgba(40, 44, 52, 0.1), rgba(40, 44, 52, 0.9)) !important; } figure.shiki { background-color: var(--hl-bg) !important; color: var(--hl-color) !important; }"},{"title":"赞助我","date":"2024-08-23T05:42:09.000Z","updated":"2024-08-23T05:42:10.472Z","comments":true,"path":"donate.html","permalink":"https://lpy30m.github.io/skuukzky.github.io/donate.html","excerpt":"","text":"还是留给自己买 kfc 吧"}],"posts":[{"title":"极验4九宫格","slug":"验证码识别/极验4九宫格","date":"2024-09-27T12:59:39.000Z","updated":"2024-10-01T07:52:41.020Z","comments":true,"path":"2024/09/27/验证码识别/极验4九宫格/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/09/27/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E6%9E%81%E9%AA%8C4%E4%B9%9D%E5%AE%AB%E6%A0%BC/","excerpt":"","text":"极验九宫格过程训练是根据 github 的一个库ClassificationCaptchaOcr 进行的，发布不久，原理就是加载预训练模型 resnet18，进行分类训练。 附上他的原理. 123我们可以把每张图片都切出来，然后用CNN提取图像特征 选用resnet18，再用相似度对比函数对比小图和九张大图的相似度，选出相似度最大的3张就可以了 因为给了小图，而不是文字，所以我们的特征提取的模型同样可以识别未出现的分类 验证码长这个样子 我们请求网络图片，然后根据返回内容解析，我大概爬了 200 张左右。然后根据图片文件夹切割 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import os import secrets from PIL import Image, ImageFont, ImageDraw, ImageOps from io import BytesIO def convert_png_to_jpg(png_bytes: bytes) -&gt; bytes: # 将传入的 bytes 转换为图像对象 png_image = Image.open(BytesIO(png_bytes)) # 创建一个 BytesIO 对象，用于存储输出的 JPG 数据 output_bytes = BytesIO() # 检查图像是否具有透明度通道 (RGBA) if png_image.mode == &#39;RGBA&#39;: # 创建白色背景 white_bg = Image.new(&quot;RGB&quot;, png_image.size, (255, 255, 255)) # 将 PNG 图像粘贴到白色背景上，透明部分用白色填充 white_bg.paste(png_image, (0, 0), png_image) jpg_image = white_bg else: # 如果图像没有透明度，直接转换为 RGB 模式 jpg_image = png_image.convert(&quot;RGB&quot;) # 将转换后的图像保存为 JPG 格式到 BytesIO 对象 jpg_image.save(output_bytes, format=&quot;JPEG&quot;) # 返回保存后的 JPG 图像的 bytes return output_bytes.getvalue() def crop_image(image_bytes, coordinates): img = Image.open(BytesIO(image_bytes)) width, height = img.size grid_width = width // 3 grid_height = height // 3 cropped_images = [] for coord in coordinates: y, x = coord left = (x - 1) * grid_width upper = (y - 1) * grid_height right = left + grid_width lower = upper + grid_height box = (left, upper, right, lower) cropped_img = img.crop(box) cropped_images.append(cropped_img) return cropped_images if __name__ == &quot;__main__&quot;: # 切割顺序，这里是从左到右，从上到下[x,y] coordinates = [ [1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3], ] dir_path = r&#39;/Users/jiangxia/PycharmProjects/pythonProject/滑块/极验4九宫格/pic/bg&#39; # dir_path = r&#39;/Users/jiangxia/PycharmProjects/pythonProject/滑块/极验4九宫格/pic/icon&#39; files = os.listdir(dir_path) print(files) for file in files: img = os.path.join(dir_path, file) # print(img) with open(img, &quot;rb&quot;) as rb: bg_img = rb.read() cropped_images = crop_image(bg_img, coordinates) # 一个个保存下来 for j, img_crop in enumerate(cropped_images): img_crop.save(f&quot;./image_test/bg/bg_{secrets.token_hex(4)}.jpg&quot;) # 图标格式转换 # with open(img, &quot;rb&quot;) as rb: # icon_img = rb.read() # icon_img_jpg = convert_png_to_jpg(icon_img) # with open(f&quot;./image_test/icon/icon_{secrets.token_hex(4)}.jpg&quot;, &quot;wb&quot;) as wb: # wb.write(icon_img_jpg) # with open(&quot;/Users/jiangxia/PycharmProjects/pythonProject/滑块/极验4九宫格/pic/bg/bg-1e898021.png&quot;, &quot;rb&quot;) as rb: # bg_img = rb.read() # cropped_images = crop_image(bg_img, coordinates) # # 一个个保存下来 # for j, img_crop in enumerate(cropped_images): # img_crop.save(f&quot;./image_test/bg{j}.jpg&quot;) # # 图标格式转换 # with open(&quot;image_test/icon_yizi.png&quot;, &quot;rb&quot;) as rb: # icon_img = rb.read() # icon_img_jpg = convert_png_to_jpg(icon_img) # with open(&quot;./image_test/icon_yizi.jpg&quot;, &quot;wb&quot;) as wb: # wb.write(icon_img_jpg) 然后自己根据小图的内容，命名分类。 一定要把小图也放进文件夹中，这样才可以保证准确率。 其中还要注意的是小图和极验 4 文字一样，需要渲染底图 其中文件夹内容长这样 然后运行他的 resnet18.py 进行训练。我这里是 80 轮，然后只留了最后一轮的，他的代码是每一轮训练的模型都会保存导致占用很大。 然后运行 pth2onnx.py 转为 onnx。接下来就可以整合代码了。 还需要注意的是 12# 初始化模型 num_classes就是目录下的子文件夹数目，每个子文件夹对应一个分类，模型输出的向量长度也是这个长度 model = MyResNet18(num_classes=82)。 其中的 82 是你的文件夹个数，我这里只分类了 82 种，作者本人好像分类了 91 种。 最后就可以请求参数了。 1&#39;{&quot;passtime&quot;:494,&quot;userresponse&quot;:[[3,1],[2,1],[2,2]],&quot;device_id&quot;:&quot;&quot;,&quot;lot_number&quot;:&quot;e4175cd409a14621b978acde8875adf0&quot;,&quot;pow_msg&quot;:&quot;1|0|md5|2024-09-27T21:23:30.718157+08:00|54088bb07d2df3c46b79f80300b0abbe|e4175cd409a14621b978acde8875adf0||432a97d6c68575f0&quot;,&quot;pow_sign&quot;:&quot;7b8ac143d55535860bf8bfab61bb4697&quot;,&quot;geetest&quot;:&quot;captcha&quot;,&quot;lang&quot;:&quot;zh&quot;,&quot;ep&quot;:&quot;123&quot;,&quot;biht&quot;:&quot;1426265548&quot;,&quot;gee_guard&quot;:{&quot;roe&quot;:{&quot;aup&quot;:&quot;3&quot;,&quot;sep&quot;:&quot;3&quot;,&quot;egp&quot;:&quot;3&quot;,&quot;auh&quot;:&quot;3&quot;,&quot;rew&quot;:&quot;3&quot;,&quot;snh&quot;:&quot;3&quot;,&quot;res&quot;:&quot;3&quot;,&quot;cdc&quot;:&quot;3&quot;}},&quot;A0Bw&quot;:&quot;rO9P&quot;,&quot;em&quot;:{&quot;ph&quot;:0,&quot;cp&quot;:0,&quot;ek&quot;:&quot;11&quot;,&quot;wd&quot;:1,&quot;nt&quot;:0,&quot;si&quot;:0,&quot;sc&quot;:0}}&#39; 剩下就是参数了，极验 w 可以去 github 搜，开源挺多的，作者也是很贴心的，直接把坐标返回了[[],[],[]]的格式,我们直接替换 userresponse，其他的根据开源代码改改就能通过了。 结果","categories":[{"name":"验证码识别","slug":"验证码识别","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"}],"tags":[]},{"title":"4399游戏盒参数分析","slug":"逆向/4399游戏盒参数分析","date":"2024-09-11T12:12:08.000Z","updated":"2024-09-21T11:07:42.083Z","comments":true,"path":"2024/09/11/逆向/4399游戏盒参数分析/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/09/11/%E9%80%86%E5%90%91/4399%E6%B8%B8%E6%88%8F%E7%9B%92%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/","excerpt":"","text":"4399 游戏盒 app 分析sign: 17260222923525310800735291TFDppmkYwb4&#x3D;17751935523ef2vx#sf^FlklSD9sdf(m$&amp;qw%d7po 就是请求 data 中的参数 去掉 refer 和 model 排序拼接 ef2vx#sf^FlklSD9sdf(m$&amp;qw%d7po md5 des Key 是 8 位 这里循环取 8 位，常量 16c78 就是。根据他的代码翻译一下，然后再转一下 utf8 1u!~#7@w0 iv 12 位的 iv 循环 12 次 所以查看 sub_5BCC 的逻辑 取值是从后往前取得 两个一组 就是 0x1234567890ABCDEF","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"scrape.center APP8逆向分析","slug":"逆向/scrape-center-APP8逆向分析","date":"2024-08-28T05:24:48.000Z","updated":"2024-09-21T11:08:13.610Z","comments":true,"path":"2024/08/28/逆向/scrape-center-APP8逆向分析/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/08/28/%E9%80%86%E5%90%91/scrape-center-APP8%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/","excerpt":"","text":"scrape.center APP8 逆向分析前言之前在整理语雀笔记的时候，误打误撞看到了一个网站，Python 爬虫案例 | Scrape Center，后面经过了解知道了是业内大佬崔庆才的一个网站，其中有一些爬虫练手的案例，我觉得挺适合我们平时入手联系，整体难度和平时遇到的也接近相似，再次记录一下对于 app 中的第八题分析过程。 分析过程软件没壳，直接定位 encrypt 方法，然后是一个 so 层的方法，直接去 app 目录下的 lib 中找到 arm64 的 so 文件，拖入到 ida 中反编译既可，我就在再此详细 贴图分析了。 要找的加密值是 token。长这个模样。ZjRhNTk2N2NhMzU2NTFjNDNmMWJkNTc2Mzk4MGM5MDdmOTE0ZWY5NSwxNzI0ODIxODkz 其实 base64 一下就是这样。f4a5967ca35651c43f1bd5763980c907f914ef95,1724821893 第一段 40 位，在熟知的加密中，SHA1 的结果 就为 40 位，后面就是一个时间戳了。 hook encrypt 方法 传入一个 str 和 一个 int。 “&#x2F;api&#x2F;movie” 和 0 其实就是抓包中的接口和 offset 的值 so 里面是静态方法，直接在到处函数中搜索 encrypt 就可以定位到。整体是这样的结构 一眼望过去了，没有混淆，没有控制流，果然练手的 app 就是舒服。 我们也能明显的看到，函数流程中有个 sha1 的函数，那估计就没跑了，直接 hook sha1 函数入参。秒杀 ，此篇完结。 哈哈，开玩笑的，要真有这么简单，也不会单独拿出来做记录了。 sha1 的参数实际上是一个结构体，直接 hook 行不通，还需要跟进一层。 我们先通读下代码吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586__int64 __fastcall Java_com_goldze_mvvmhabit_utils_NativeUtils_encrypt( _JNIEnv *a1, __int64 a2, __int64 a3, unsigned int a4) // a2好像没用到 a3 &#39;/api/movie&#39; a4 0 { int v4; // w1 __int64 v5; // x1 __int64 v7; // [xsp+0h] [xbp-180h] char *v8; // [xsp+8h] [xbp-178h] std::__ndk1 *v9; // [xsp+20h] [xbp-160h] __int64 StringUTFChars; // [xsp+28h] [xbp-158h] _BYTE v14[24]; // [xsp+60h] [xbp-120h] BYREF _QWORD v15[3]; // [xsp+78h] [xbp-108h] BYREF _QWORD v16[3]; // [xsp+90h] [xbp-F0h] BYREF _BYTE v17[24]; // [xsp+A8h] [xbp-D8h] BYREF _QWORD v18[3]; // [xsp+C0h] [xbp-C0h] BYREF _QWORD v19[3]; // [xsp+D8h] [xbp-A8h] BYREF __int64 v20[3]; // [xsp+F0h] [xbp-90h] BYREF __int64 v21[3]; // [xsp+108h] [xbp-78h] BYREF _BYTE v22[24]; // [xsp+120h] [xbp-60h] BYREF _BYTE v23[24]; // [xsp+138h] [xbp-48h] BYREF _BYTE v24[24]; // [xsp+150h] [xbp-30h] BYREF __int64 v25; // [xsp+168h] [xbp-18h] // 一堆变量定义 先忽略 v25 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40); // 数组声明 sub_16370(v24); // GetStringUTFChars 转化c的字符串 StringUTFChars = _JNIEnv::GetStringUTFChars((__int64)a1, a3, 0LL); // char数组转为string 后存入v23 std::string::basic_string&lt;decltype(nullptr)&gt;(v23, StringUTFChars); // 存放输入 sub_16394((__int64)v24, (__int64)v23); // 问了一下通义。说是析构函数 用于销毁对象并释放对象所占用的资源 那么说明 v23被删掉了 std::string::~string(v23); // 同上 把 9fdLnciVh4FxQbri 转为string 并放入v22 std::string::basic_string&lt;decltype(nullptr)&gt;(v22, &quot;9fdLnciVh4FxQbri&quot;); sub_16394((__int64)v24, (__int64)v22); // 同上操作 std::string::~string(v22); std::to_string(v21, (std::__ndk1 *)a4, v4); sub_16394((__int64)v24, (__int64)v21); // 同上操作 std::string::~string(v21); // 获取时间 v9 = (std::__ndk1 *)time(0LL); // 转化 字符串 std::to_string(v20, v9, v5); sub_1645C(v24, v20); // join拼接将v24内容拼接 存入 v18 44LL 其实代表了44 而44的ascii值为 , join(v18, v24, 44LL); // 进行sha1 计算 sha1(v19, v18); // 删除 v18 std::string::~string(v18); // 新数组声明 sub_16370(v17); // 数组存放 v19 sub_1645C(v17, v19); // 数组存放 v20 sub_1645C(v17, v20); // 拼接 v17 ,拼接 存入v6 join(v16, v17, 44LL); std::string::basic_string(v14, v16); // base64 存入v15 b64encode(v15, v14); //删除v14 std::string::~string(v14); // v15转化char数组 v8 = (char *)sub_165EC(v15); // 转化 NewStringUTF v7 = _JNIEnv::NewStringUTF(a1, v8); // 删除 其他值 std::string::~string(v15); std::string::~string(v16); sub_16610(v17); std::string::~string(v19); std::string::~string(v20); sub_16610(v24); _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)); // 返回v7 return v7; } 其实大概就知道了， 整体代码在进行参数拼接和一个 sha1 的加密 /api/movie,9fdLnciVh4FxQbri,0,1724821893 –SHA1–&gt; f4a5967ca35651c43f1bd5763980c907f914ef95 与上文一样，最后再把时间戳给加上。 结果是一致的。 如果想深度探索,可以在利用 unidbg 跑一下结果 。 附上代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.spdiercenter; import com.alibaba.fastjson.util.IOUtils; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.Unicorn2Factory; import com.github.unidbg.debugger.Debugger; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.DalvikModule; import com.github.unidbg.linux.android.dvm.DvmClass; import com.github.unidbg.linux.android.dvm.StringObject; import com.github.unidbg.linux.android.dvm.VM; import com.github.unidbg.memory.Memory; import java.io.File; public class SpcUtil { private final AndroidEmulator emulator; private final VM vm; private final Module module; private final DvmClass NativeHelper; private final boolean logging; SpcUtil(boolean logging) { this.logging = logging; emulator = AndroidEmulatorBuilder.for64Bit() .setProcessName(&quot;com.goldze.mvvmhabit&quot;) .addBackendFactory(new Unicorn2Factory(true)) .build(); // 创建模拟器实例，要模拟32位或者64位，在这里区分 final Memory memory = emulator.getMemory(); // 模拟器的内存操作接口 memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析 vm = emulator.createDalvikVM(); // 创建Android虚拟机 vm.setVerbose(logging); // 设置是否打印Jni调用细节 DalvikModule dm = vm.loadLibrary(new File(&quot;/Users/jiangxia/unidbg/apks/tujia/libnative.so&quot;), false); // 加载libttEncrypt.so到unicorn虚拟内存，加载成功以后会默认调用init_array等函数 dm.callJNI_OnLoad(emulator); // 手动执行JNI_OnLoad函数 module = dm.getModule(); // 加载好的libttEncrypt.so对应为一个模块 NativeHelper = vm.resolveClass(&quot;com/goldze/mvvmhabit/utils/NativeUtils&quot;);//加载类 } void destroy() { IOUtils.close(emulator); if (logging) { System.out.println(&quot;destroy&quot;); } } public void hooksha1() { Debugger MyDbg = emulator.attach(); // MyDbg.addBreakPoint(module.base + 0xC18); //断点地址 // MyDbg.addBreakPoint(module.base + 0x15F38); //断点地址 // MyDbg.addBreakPoint(module.base + 0x15430); //断点地址 // MyDbg.addBreakPoint(module.base + 0x17F1C); //断点地址 MyDbg.addBreakPoint(module.base + 0x15B9C); //断点地址 } public static void main(String[] args) throws Exception { SpcUtil test = new SpcUtil(true); test.hooksha1(); test.callFunc(); test.destroy(); } void callFunc() { String data = &quot;/api/movie&quot;; int p2 = 0; StringObject stringObject = NativeHelper.callStaticJniMethodObject(emulator, &quot;encrypt(Ljava/lang/String;I)Ljava/lang/String;&quot;, data, p2); System.out.println(stringObject); } } 代码整合就不写了，因为可能是太久了，app 中的数据都不加载了，我们分析得到的结果一直就够了。 末尾继续努力吧，有机会写一下易盾的空间推理。","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"360点选识别","slug":"验证码识别/验证码识别","date":"2024-08-24T08:08:48.000Z","updated":"2024-08-28T06:20:13.527Z","comments":true,"path":"2024/08/24/验证码识别/验证码识别/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/08/24/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/","excerpt":"","text":"360 点选实战(yolvo8+孪生)过程我们使用 python 脚本 爬取保存大概 100 多张图片即可，放在本地文件夹下。接着使用X-AnyLabeling 进行数据标注。主要注意的是需要导出中转为 yolo 格式，这样的话可以自动转为 yolo 可识别的 txt 文件接下来我们打标就可，因为是做孪生，所以我们不需要详细分类，给每个标签打上固定的标签即可，我这里是 labels。 依次标注即可，360 这个并没有太多的图片，基本都是相同种类重复的偏多，就是改个字体。打完标之后我们就可以利用一个脚本 进行格式转化了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189# -*- coding: utf-8 -*- import json import os import random import shutil def json2yolo(json_folder, class_dic): &quot;&quot;&quot;讲labelme的json文件转成txt文件 {&quot;notch&quot;: &#39;0&#39;}&quot;&quot;&quot; file_list = os.listdir(json_folder) txt_folder = os.path.dirname(json_folder) + &quot;\\labels_txt&quot; if not os.path.exists(txt_folder): os.makedirs(txt_folder) json_file_list = [x for x in file_list if &quot;.json&quot; in x] # 获取所有json文件的路径 for p in json_file_list: json_file = os.path.join(json_folder, p) with open(json_file, encoding=&#39;utf-8&#39;) as f: data = json.loads(f.read()) img_w = data[&quot;imageWidth&quot;] # 获取json文件里图片的宽高 img_h = data[&quot;imageHeight&quot;] all_line = &#39;&#39; for i in data[&quot;shapes&quot;]: # 归一化坐标点。并得到cx,cy,w,h [[x1, y1], [x2, y2]] = i[&#39;points&#39;] x1, x2 = x1 / img_w, x2 / img_w y1, y2 = y1 / img_h, y2 / img_h cx = (x1 + x2) / 2 cy = (y1 + y2) / 2 w = abs(x2 - x1) h = abs(y2 - y1) # 将数据组装成yolo格式 line = f&quot;%s %.4f %.4f %.4f %.4f\\n&quot; % (class_dic[i[&#39;label&#39;]], cx, cy, w, h) # 生成txt文件里每行的内容 all_line += line # print(all_line) txt_file = os.path.join(txt_folder, p.replace(&#39;json&#39;, &#39;txt&#39;)) with open(txt_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as fh: fh.write(all_line) # json2yolo(r&#39;D:\\Web_Decryption\\SEASON\\0527\\test&#39;, {&quot;殊&quot;:&quot;0&quot;,&quot;乡&quot;:&quot;1&quot;,&quot;趋&quot;:&quot;2&quot;,}) def shape2id(json_folder): classes2id = {} classes_all = set() num = 0 jsons = os.listdir(json_folder) for i in jsons: json_path = os.path.join(json_folder, i) with open(json_path, &#39;r&#39;, encoding=&quot;utf-8&quot;) as f: json_data = json.load(f) # print(json_data[&#39;shapes&#39;]) for j in json_data[&#39;shapes&#39;]: if j[&#39;label&#39;] not in classes2id: classes2id[j[&#39;label&#39;]] = num num += 1 classes_all.add(j[&#39;label&#39;]) print(classes2id) print(&quot;所有分类&quot;, classes_all) return classes2id # shape2id(r&#39;D:\\day_soft\\Labelme\\custom_model\\lably&#39;) def split_images_floder(img_dir, label_dir, img_suffix=&#39;.png&#39;): &quot;&quot;&quot; 将数据集划分为训练集，验证集，测试集 &quot;&quot;&quot; # 1.确定原图片数据集路径 datasetimg_dir = img_dir # 确定原label数据集路径 datasetlabel_dir = label_dir # 2.确定数据集划分后保存的路径 _f = os.path.dirname(img_dir) split_dir = os.path.join(_f, &quot;dataset&quot;) train_dir = os.path.join(split_dir, &quot;train&quot;) valid_dir = os.path.join(split_dir, &quot;valid&quot;) test_dir = os.path.join(split_dir, &quot;test&quot;) dir_list = [train_dir, valid_dir, test_dir] image_label = [&#39;images&#39;, &#39;labels&#39;] for i in range(len(dir_list)): for j in range(len(image_label)): new_dir = os.path.join(dir_list[i], image_label[j]) if not os.path.exists(new_dir): os.makedirs(new_dir) # 3.确定将数据集划分为训练集，验证集，测试集的比例 train_pct = 0.9 valid_pct = 0.1 test_pct = 0 # 4.划分 imgs = os.listdir(datasetimg_dir) # 展示目标文件夹下所有的文件名 imgs = list(filter(lambda x: x.endswith(img_suffix), imgs)) # 取到所有以.png结尾的文件，如果改了图片格式，这里需要修改 random.shuffle(imgs) # 乱序路径 img_count = len(imgs) # 计算图片数量 train_point = int(img_count * train_pct) # 0:train_pct valid_point = int(img_count * (train_pct + valid_pct)) # train_pct:valid_pct for i in range(img_count): if i &lt; train_point: # 保存0-train_point的图片到训练集 out_dir = os.path.join(train_dir, &#39;images&#39;) label_out_dir = os.path.join(train_dir, &#39;labels&#39;) elif i &lt; valid_point: # 保存train_point-valid_point的图片到验证集 out_dir = os.path.join(valid_dir, &#39;images&#39;) label_out_dir = os.path.join(valid_dir, &#39;labels&#39;) else: # 保存test_point-结束的图片到测试集 out_dir = os.path.join(test_dir, &#39;images&#39;) label_out_dir = os.path.join(test_dir, &#39;labels&#39;) target_path = os.path.join(out_dir, imgs[i]) # 指定目标保存路径 src_path = os.path.join(datasetimg_dir, imgs[i]) # 指定目标原图像路径 label_target_path = os.path.join(label_out_dir, imgs[i][0:-4] + &#39;.txt&#39;) label_src_path = os.path.join(datasetlabel_dir, imgs[i][0:-4] + &#39;.txt&#39;) shutil.copy(src_path, target_path) # 复制图片 shutil.copy(label_src_path, label_target_path) # 复制txt print(&#39;train:{}, valid:{}, test:{}&#39;.format(train_point, valid_point - train_point, img_count - valid_point)) #split_images_floder(r&quot;C:\\Users\\24572\\PycharmProjects\\pythonProject\\360click\\images&quot;, r&quot;C:\\Users\\24572\\PycharmProjects\\pythonProject\\360click\\labels&quot;) def make_yolo_yaml(yaml_name, image_dir, class_names): &quot;&quot;&quot;生成yolo格式的yaml文件&quot;&quot;&quot; if not os.path.exists(yaml_name): os.makedirs(yaml_name) nums = len(class_names) # 生成数据集配置.yaml with open(yaml_name, &quot;w&quot;, encoding=&#39;utf-8&#39;) as f: f.write(f&quot;train: {image_dir}/train/images\\n&quot;) f.write(f&quot;val: {image_dir}/valid/images\\n&quot;) f.write(f&quot;test: {image_dir}/test/images\\n&quot;) f.write(&quot;\\n&quot;) f.write(f&quot;nc: {nums}\\n&quot;) f.write(f&quot;names: {class_names}\\n&quot;) make_yolo_yaml(r&quot;C:\\Users\\24572\\PycharmProjects\\pythonProject\\360click\\font.yaml&quot;, r&#39;C:\\Users\\24572\\PycharmProjects\\pythonProject\\360click\\dataset&#39;, [&quot;labels&quot;]) def create_valid_test_folder(image_dir, labels_dir, img_suffix=&#39;.jpg&#39;): &quot;&quot;&quot; :param image_dir: D:\\Yzmtrain\\yzmdata\\dyclick_524\\images_all :param labels_dir: D:\\Yzmtrain\\yzmdata\\dyclick_524\\labels_all :param img_suffix: :return: &quot;&quot;&quot; _folder = os.path.dirname(image_dir) for dirs in [&#39;train/images&#39;, &#39;train/labels&#39;, &#39;valid/images&#39;, &#39;valid/labels&#39;, &#39;test/images&#39;, &#39;test/labels&#39;]: try: os.makedirs(os.path.join(image_dir, dirs)) except FileExistsError: print(f&#39;{dirs} 目录已存在&#39;) image_file_list = os.listdir(image_dir) total_num = len(image_file_list) train_num = int((total_num-10)/7) valid_num = total_num - 10 - train_num for img_name in image_file_list[:10]: json_name = img_name.replace(img_suffix, &quot;.json&quot;) img_src = os.path.join(image_dir, img_name) dst_images = os.path.join(f&quot;{_folder}/test/images&quot;, img_name) os.rename(img_src, dst_images) labels_src = os.path.join(labels_dir, json_name) dst_labels = os.path.join(f&quot;{_folder}/test/labels&quot;, json_name) os.rename(labels_src, dst_labels) def rename_file(): aa_all = {} json_folder = &quot;D:\\Yzmtrain\\yzmdata\\hanzi_1\\hanzi\\hanzi\\js11&quot; file_list = os.listdir(json_folder) json_file_list = [x for x in file_list if &quot;.json&quot; in x] # 获取所有json文件的路径 for p in json_file_list: json_file = os.path.join(json_folder, p) image_file = json_file.replace(&quot;\\js11&quot;, &#39;&#39;).replace(&quot;json&quot;, &quot;jpg&quot;) with open(json_file, encoding=&#39;utf-8&#39;) as f: data = json.loads(f.read()) print(json_file, image_file) print(p, data[&#39;shapes&#39;][0][&#39;label&#39;]) aa_all[p] = f&quot;{data[&#39;shapes&#39;][0][&#39;label&#39;]}_{p[2:]}&quot; os.rename(json_file, f&quot;D:\\Yzmtrain\\yzmdata\\hanzi_1\\hanzi\\hanzi\\js11\\\\{data[&#39;shapes&#39;][0][&#39;label&#39;]}_{p[2:]}&quot;) os.rename(image_file, f&quot;D:\\Yzmtrain\\yzmdata\\hanzi_1\\hanzi\\hanzi\\\\{data[&#39;shapes&#39;][0][&#39;label&#39;]}_{p[2:]}&quot;.replace(&quot;json&quot;, &quot;jpg&quot;)) print(aa_all) # rename_file() # _folder = &quot;D:\\Yzmtrain\\yzmdata\\chinese&quot; # file_list = os.listdir(_folder) # json_file_list = [x for x in file_list if &quot;.json&quot; in x] # 获取所有json文件的路径 # for p in json_file_list: # json_file = os.path.join(_folder, p) # os.rename(json_file, f&quot;D:\\Yzmtrain\\yzmdata\\chinese_json\\\\{p}&quot;) 运行 split_images_floder 之后本地就会生成 一些文件夹，其中存放着划分的验证机和数据集之后创建一个 font.yaml 的文件 在运行 make_yolo_yaml 就生成了支持 yolov8 训练的配置文件。以上都大功告成之后，我们就可以开始进行训练了 123from ultralytics import YOLO model = YOLO(&quot;yolov8n.pt&quot;) # load a pretrained model (recommended for training) results = model.train(data=&quot;font.yaml&quot;, epochs=200, cache=True, imgsz=320, batch=16, workers=0, device=&#39;cuda&#39;) 之后我们会在当前 runs&#x2F;detect&#x2F;train&#x2F;weights 得到一个 best.pt 文件 这就是我们后面需要识别和切割的模型了我们利用Siamese-pytorch 我们本地下载 GitHub 中提供的模型，并把它放入 model_data 中，然后我们运行 predict.py 文件 来测试环境是否正确。 如果没问题那么就可以开始我们正式训练了.首先我们来明确一下思路。 需要先获得一张图片 之后要利用 yolov8 进行识别切割，并保存在一个文件夹中 我们要遍历切割后的文件夹，并且以某一张图片来作为基准，与其他对比。同时获取裁切后的坐标，方便后续找到不同图片时也能得到对应坐标。 情况 1:对比后找到其他图片为相似度最小的一张 情况 2:当前这张要对比的图片与其他 4 张都不同，是特立独行的图片 4.提交验证，有加密处理加密，有验证提交验证数据包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177import json import random import time import execjs from PIL import Image from ultralytics import YOLO from siamese import Siamese import cv2 import numpy as np import os import requests token = &#39;e7e3456c9521de075c0ed00a7d6d7480&#39; headers = { &quot;accept&quot;: &quot;*/*&quot;, &quot;accept-language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&quot;, &quot;cache-control&quot;: &quot;no-cache&quot;, &quot;pragma&quot;: &quot;no-cache&quot;, &quot;referer&quot;: &quot;https://sqhd.u.360.cn/&quot;, &quot;sec-ch-ua&quot;: &quot;\\&quot;Not)A;Brand\\&quot;;v=\\&quot;99\\&quot;, \\&quot;Microsoft Edge\\&quot;;v=\\&quot;127\\&quot;, \\&quot;Chromium\\&quot;;v=\\&quot;127\\&quot;&quot;, &quot;sec-ch-ua-mobile&quot;: &quot;?0&quot;, &quot;sec-ch-ua-platform&quot;: &quot;\\&quot;Windows\\&quot;&quot;, &quot;sec-fetch-dest&quot;: &quot;script&quot;, &quot;sec-fetch-mode&quot;: &quot;no-cors&quot;, &quot;sec-fetch-site&quot;: &quot;same-site&quot;, &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36 Edg/127.0.0.0&quot; } cookies = { &quot;__huid&quot;: &quot;11xEyO13c+M4dgY6TiYNLPb9LRVgaku/GXVMp/qF0GMNQ=&quot;, &quot;__guid&quot;: &quot;230272478.3358358338768799744.1704856402001.2004&quot;, &quot;__NS_Q&quot;: &quot;u%3Dyv083024%26n%3D%26le%3D%26m%3DZGp3WGWOWGWOWGWOWGWOWGWOZGL4%26qid%3D3403077592%26im%3D1_t01923d359dad425928%26src%3Dpcw_quake%26t%3D1&quot;, &quot;Q&quot;: &quot;u%3Dyv083024%26n%3D%26le%3D%26m%3DZGp3WGWOWGWOWGWOWGWOWGWOZGL4%26qid%3D3403077592%26im%3D1_t01923d359dad425928%26src%3Dpcw_quake%26t%3D1&quot;, &quot;__DC_gid&quot;: &quot;208211024.767422413.1715657472373.1715657472383.2&quot;, &quot;T&quot;: &quot;s%3Dfe966e73df014d7fc952331d9cd492cb%26t%3D1715925046%26lm%3D%26lf%3D4%26sk%3D6d22cff2c2004dc594d8a9cd5674ca07%26mt%3D1715925046%26rc%3D%26v%3D2.0%26a%3D1&quot;, &quot;__NS_T&quot;: &quot;s%3Dfe966e73df014d7fc952331d9cd492cb%26t%3D1715925046%26lm%3D%26lf%3D4%26sk%3D6d22cff2c2004dc594d8a9cd5674ca07%26mt%3D1715925046%26rc%3D%26v%3D2.0%26a%3D1&quot; } # 获取验证码图片并且保存图片和一些提交验证的参数。 def get(): url = &quot;https://captcha.bpd.360.cn/v1/get&quot; params = { &quot;appid&quot;: &quot;LS3yVZANuLCqvFn1IWNGVNeC37ExAbuL&quot;, &quot;token&quot;: token, &quot;ty&quot;: &quot;3&quot;, } response = requests.get(url, headers=headers, cookies=cookies, params=params).json() print(response) pic_url = response[&quot;data&quot;][&quot;pic&quot;][&quot;bg&quot;] ftoken = response[&quot;data&quot;][&quot;ftoken&quot;] pic_ = requests.get(pic_url,headers=headers) with open(f&quot;./img/{int(time.time()*1000)}.png&quot;,&#39;wb&#39;) as f: f.write(pic_.content) print(&quot;完成&quot;) return pic_url,ftoken pic_url,ftoken = get() # 加载YOLO模型 model = YOLO(&#39;best.pt&#39;) # 利用YOLO进行 指定坐标裁切 def cai_save(img_big): results = model.predict(img_big) img_big_cai = [] # 裁剪图片并保存在列表中 center_coordinates = {} for idx, box in enumerate(results[0].boxes.xyxy): box = list(map(int, box)) img_c = img_big[box[1]:box[3], box[0]:box[2]] img_big_cai.append(img_c) center_x = int((box[0] + box[2]) / 2) center_y = int((box[1] + box[3]) / 2) #获取裁切后的坐标 center_coordinates[f&#39;qie_{idx + 1}&#39;] = {&#39;center_x&#39;: center_x, &#39;center_y&#39;: center_y} # 保存裁剪后的图片 folder_path = &#39;./cai_big_images&#39; if not os.path.exists(folder_path): os.makedirs(folder_path) for idx, img_array in enumerate(img_big_cai, start=1): # 生成文件名 filename = f&quot;qie_{idx}.jpg&quot; filepath = os.path.join(folder_path, filename) # 保存图片 cv2.imwrite(filepath, img_array) return center_coordinates dir_path = r&#39;E:\\Siamese-pytorch\\img&#39; files = os.listdir(dir_path) #遍历目录下的图片文件 print(files) for file in files: img = cv2.imread(os.path.join(dir_path, file)) center_coordinates = cai_save(img) print(center_coordinates) #输出坐标 print(&quot;全部切分完成，开始孪生对比&quot;) # 创建一个 Siamese 类的实例 model = Siamese() def compare_with_reference(folder_path, reference_filename): min_similarity = float(&#39;inf&#39;) # 存储与参考图片相比最不相似的图片的相似度 unique_image_filename = None # 存储最不相似的图片文件名 reference_image = Image.open(os.path.join(folder_path, reference_filename)) for filename in os.listdir(folder_path): if filename.endswith(&quot;.jpg&quot;) or filename.endswith(&quot;.jpeg&quot;): if filename == reference_filename: continue # 跳过参考图片本身 # 加载图片 image_path = os.path.join(folder_path, filename) image = Image.open(image_path) # 使用模型计算相似度概率 孪生识别 probability = model.detect_image(reference_image, image) probability_value = probability.item() # 如果当前图片的相似度低于之前记录的最低相似度，则更新 if probability_value &lt; min_similarity: min_similarity = probability_value unique_image_filename = filename # 返回最不相似的图片文件名及其相似度 return unique_image_filename, min_similarity folder_path = r&quot;E:\\Siamese-pytorch\\cai_big_images&quot; #裁切后图片位置 unique_image_filename, min_similarity = compare_with_reference(folder_path, &#39;qie_2.jpg&#39;) #打开参考图片 qie_2.jpg if unique_image_filename is not None: unique_image_key = unique_image_filename.replace(&quot;.jpg&quot;,&quot;&quot;) unique_image_coordinates = center_coordinates.get(unique_image_key,None) print(f&quot;特立独行的图片是 {unique_image_filename}，相似度为 {min_similarity},中心坐标为: {unique_image_coordinates}&quot;) # # 显示特立独行的图片 # unique_image_path = os.path.join(folder_path, unique_image_filename) # unique_image = cv2.imread(unique_image_path) # cv2.imshow(&#39;Unique Image&#39;, unique_image) # cv2.waitKey(0) # cv2.destroyAllWindows() print(unique_image_coordinates) #####网站加密的轨迹坐标处理 x = unique_image_coordinates[&#39;center_x&#39;] y = unique_image_coordinates[&#39;center_y&#39;] final_list = [] print(&#39;x&#39;, x) print(&#39;y&#39;, y) # 网页实际缩放了图片 比例是1/2 所以要乘0.5 对应网页 entry = { &quot;x&quot;: int(x * 0.5), &quot;y&quot;: int(y * 0.5), &quot;t&quot;: int(time.time() * 1000) + random.randint(0, 150), # 固定时间戳 &quot;type&quot;: &quot;mousedown&quot; # 固定操作类型 } final_list = [entry] guiji = json.dumps(final_list) print(guiji) # aes加密 d = execjs.compile(open(&#39;./1.js&#39;, &#39;r&#39;, encoding=&quot;utf-8&quot;).read()).call(&#39;get_d&#39;, guiji) print(d) #提交验证 url = &quot;https://captcha.bpd.360.cn/v1/verify&quot; params = { &quot;appid&quot;: &quot;LS3yVZANuLCqvFn1IWNGVNeC37ExAbuL&quot;, &quot;token&quot;: token, &quot;ftoken&quot;: ftoken, &quot;d&quot;: d, &quot;scale&quot;: &quot;0.5&quot;, &quot;ty&quot;: &quot;3&quot;, &quot;src&quot;: &quot;&quot;, &quot;imgUrl&quot;: pic_url, } response = requests.get(url, headers=headers, cookies=cookies, params=params) print(response.text) 结果验证到此完结。 通过了还是可以的","categories":[{"name":"验证码识别","slug":"验证码识别","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"}],"tags":[]},{"title":"安居客参数分析","slug":"逆向/安居客参数分析","date":"2024-08-23T05:52:22.000Z","updated":"2024-09-21T11:08:58.178Z","comments":true,"path":"2024/08/23/逆向/安居客参数分析/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/08/23/%E9%80%86%E5%90%91/%E5%AE%89%E5%B1%85%E5%AE%A2%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/","excerpt":"","text":"安居客参数分析前言手机里之前装过很多杂乱软件，最近闲来无事，又在学习 app 的东西，翻来翻来就找到了这个找房软件，于是想着分析一下，在此记录一下过程，也算是成长过程的小经历了，话不多开，分析开始。 请求分析 这个抓包软件是 Proxyman，Charles 在 mac 我目前还没找到好的汉化的，英文的用的也不是很舒服，所以就用 Proxyman 代替了，我们看到了加密参数特别显眼的就是nsign和 nsign_uuid 应该是和nsign有关和get_md5&#96; 参数分析做 app 逆向第一步肯定就是反编译了，不过在此之前我们还需要查看 app 是否加固，否则没办法得到大概的源代码，我们用 appmsg 进行查看。 ​ 很好啊，没有加固，我们直接 jadx 进行反编译即可。 nsign 进入了 SignUtil.c 的方法，而 SignUtil.c 则在函数中调用了一个 getSign0 的 native 方法。 ​ 我们直接打开 ida 啊，去找一下 SignUtil 这个 so 文件 ​ 是个静态注册，而且代码也没什么混淆，还是很利于我们分析的，其实我们也可以trace_natives这个 ida 插件，就能获取 SO 代码段中所有函数的偏移地址，再使用 frida-trace 批量 trace so 函数的调用。(由于 mac 下暂无高版本的 ida pro,所以我此处用 Windows 的 ida7.7 演示.) 图没截全，我们根据最开始的 sub_18f0 找过去，我们先静态分析一下代码, 发现 get_sign 这个函数比较亮眼，而我们刚才 trace 的过程中也有这个函数的调用，所以我们继续反编译分析查看 1qsort(v11, v9, 24LL, sub_185C); 看到一个 sub_185c 这个函数的调用，其实我们大概能根据 qsort 猜出来，他是根据全面的 hook 的请求参数来进行一个 sort 排序， 在下文我们能看到这个”bcb2e93c6b527180099601a2dd8ef8b1”这个字符串，很大可能性是在下文的 SIGNMD5()这个函数中的进行 md5 加盐的操作 我们进入 SIGNMD5 函数查看 已经很像 Md5 的操作，还需经进入 sub_C18 查看 已经很明显看到 这个是 md5 加密中的 k 表的第一个 但是下文的结构也不是很像，所以我们具体要 hook 一下，然后手动 md5 加密看看，是否为标准的 md5 加密。","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"某东4.7jsvmp 算法还原","slug":"逆向/某东4-7jsvmp-算法还原","date":"2024-08-23T04:44:22.000Z","updated":"2024-09-21T11:10:22.885Z","comments":true,"path":"2024/08/23/逆向/某东4-7jsvmp-算法还原/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/08/23/%E9%80%86%E5%90%91/%E6%9F%90%E4%B8%9C4-7jsvmp-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F/","excerpt":"","text":"京东 h5st 4.7.4H5st以下参数皆为研究时随机参数 并不 是同一请求 全部参数 特别注意的是在 aes 加密过程中用的 fp 需要和第二段保持一致 否则将会请求失败。 12345678920240721134400770; 第一段 5t96nmyigzygygy9; 第二段 74f42; 第三段 tk03wbb161bb218ny47exhUsIoE3D7lHbxbZgTik7YqisIFvWjBTQG8XlY2fmxSJ5sec_Q95KVeW9RG8w227CEONjo52;第四段 f4a8befb0820e360d42ba0a7805b81e0; 第五段 新增一段 4.7; 第六段 1721532832275; 第七段 UOWRm8fD2k3wKIklaB5h58P7JQx1oXrg_gB7U7jVoEs1NiltSlNQddHgLqVLdjHSiXGLgu72eJ7n13kJgBCBIIHceQiv3eNMhgHk1ZUbAPT4josbXzPcT4mD-ZqTokNYpDn-IifpL1SQ_X7FmySgoTTmntIOskhmlQfn2MvsQZJE6JK80ykJk3DjWsqWSKWJyzA0_NsXY2m5NBWtpTOQ9rljTB8IWGrJR9R_aH5RLHnbpaoXOrXHhE1oJ9IZc9zRYaKSXjaFhRqhCdGqq4wW9GASnk6ddS2HYMMfOYfCLVCQkWp6f725741DXfhF94h2Kssd4eedjcIl5HIlyOlFvHsFRTmsnIOKqSLln_6hbg04svF3qgBbQVAKsqCnsVCuVTB0QCJ4pBu3aWHAKjuvyYyDwxL3E2UTOq5A8_dGSqEiSU1MrfZy--K3O56hREYguSt09mu3Rb6RtORJu8aBFo5n; 第八段 魔改aes 4b8b4c86155f61276e7a8df6ffc8dcdc 第九段 新增一段 第一段123456789101112//根据当前时间戳转换的 1721540640770 --&gt;20240721134400770 function formatTime(timestamp) { const date = new Date(timestamp); const year = date.getFullYear(); const month = (date.getMonth() + 1).toString().padStart(2, &quot;0&quot;); const day = date.getDate().toString().padStart(2, &quot;0&quot;); const hours = date.getHours().toString().padStart(2, &quot;0&quot;); const minutes = date.getMinutes().toString().padStart(2, &quot;0&quot;); const seconds = date.getSeconds().toString().padStart(2, &quot;0&quot;); const milliseconds = date.getMilliseconds().toString().padStart(3, &quot;0&quot;); return `${year}${month}${day}${hours}${minutes}${seconds}${milliseconds}`; } 第二段1234567891011121314151617//生成的 fingerprint e.generateVisitKey = function () { let t = &quot;1uct6d0jhq&quot;; //改变了 还没找到 let o = k(t, 5); let i = y(); let c = _(t, o); let s = m({ size: i, num: c }) + o + m({ size: 16 - 5 - 1 - i, num: c }) + i; let u = s.split(&quot;&quot;); let l = u.slice(0, 15); let p = u.slice(15); let v = []; while (l.length &gt; 0) { v.push((35 - parseInt(l.pop(), 36)).toString(36)); } return v.concat(p).join(&quot;&quot;); }; 第三段1//appid, 每个接口都有一个对应的值 第四段1获取到的token 第五段 1234567891011121314151617181920212223242526272829//item.jd.com (function anonymous() { return function test(tk, fp, ts, ai, algo) { // ai 为73806 且为固定数 var rd = &quot;jr6qBP48qndB&quot;; var str = &quot;&quot;.concat(tk).concat(fp).concat(ts).concat(ai).concat(rd); return algo.HmacSHA256(str, tk); }; }); /* 在经过t.algo.HMAC 时候 自写了 init和ekey 函数 其中 init函数应该是初始化字符串 ekey函数操作是 tk03w8c3e1c3e18nXPECn0kkSU01SK7QBOZ6CnS2ONny98eulgMemppU2VFRzTrfjau4E0ZztEMdpNbOHSCRv8SclwgS 反转字符串---&gt;vmp操作后得到&#39;kn3* 这个字符串暂时不知道怎么来的 但多次测试是固定的(包括更换设备更换浏览器更换账号等) 应该和某个固定字符串有关 &#39;kn3*8c3e1c3e18nXPECn0kkSU01SK7QBOZ6CnS2ONny98eulgMemppU2VFRzTrfjau4E0ZztEMdpNbOHSCRv8SclwgS */ /* [sign] __makeSign, result:{ &quot;key&quot;: &quot;1146b5b7dd7d22e0a54dbc15b88e3d3af128bbf4d9a7202f70bd17f648619b19f4a7bea82ac734a3e9846ddfa77889c82ae195fa659aab5dafcd9f39d0ca997d&quot;, &quot;signStr&quot;: &quot;cf39e022791e801e8e14831caf9ce9ba&quot;, &quot;_stk&quot;: &quot;r,t&quot;, &quot;_ste&quot;: 1, &quot;h5st&quot;: &quot;20240724162804806;65i6tgyn9m5zzzi5;73806;tk03wb5891cc618nLyxfAEBtCpMCZjxBj2zClh3zmA66NEPAbCgNviddGCDhG71yVMBcjItUgiu_ZAc3Gywo8QbnjqWT;cf39e022791e801e8e14831caf9ce9ba;4.7;1721809684806;UOmmZVMpjhlF79xYgh738cOy_ODWEgb7Yup7dEol2JF27v4kqKSLKMqNG3pEHTFJRf-odLa1vnNCtjj9ElYBbCjkPbWYU7HJlGyhMiT-SHASJA-gEkuJTMM78rLGFZdgCbfMpt-sdfRCrw57yOVdgSiAf4q2r5igXFEmLeSWWXrlTdHAfIozsGdsOPp6_VL-ffPmbpCtne3f8eV94isG75oexYsT2BBJKhorpaTxIaUrc_pQDqu4JV3kSI7KkVVqCRyjBVi0M64P8BEq_eOzchggqqWSXPIYV0Lay933IbGUEiW62DNv6DQO_bjnmEauatShWIgckcVMADGRP0IUP2w6o_DL1BZHEVhWlt3rQEUEBluS6QH1to002ho4zGr6P-A80a6PXFzj0V2CWmsbxdtefFQBuzPcacrWVP2EapUUjYoXOrXHhE1oJ9IZc9zRYaKSXjaFhRqhCdGqq4wW9GASnk6ddS2HYMMfOYfCLVCQkWp6f725741DXfhF94h2Kssd4eedjcIl5HIlyOlFvHsFRTmsnIOKqSLln_6hbg04svF3qgBbQVAKsqCnsVCuVTB0QCJ4pBu3aWHAKjuvyYyDwxL3E2UTOq5A8_dGSqEiSU1MrfZy--K3O56hREYguSt09mu3Rb6RtORJu8aBFo5n;73b25807580cfabdd047818058c75e83&quot; } hmac 如sha256 他的操作就是 先经过上述的ekey反转字符串 当作为hmac的key 密文和md5大同小异 而密文就是 tk03wb5891cc618nLyxfAEBtCpMCZjxBj2zClh3zmA66NEPAbCgNviddGCDhG71yVMBcjItUgiu_ZAc3Gywo8QbnjqWT 65i6tgyn9m5zzzi5 20240724162804806 47 73806 AfUt6ACvKwFn7n5&lt;G* tk拼接第二段在拼接第一段拼接47拼接appid拼接algo中的rd值拼接salt盐7n5&lt;G*后续操作同下述操作*/ 1234567891011tk03wbb161bb218ny47exhUsIoE3D7lHbxbZgTik7YqisIFvWjBTQG8XlY2fmxSJ5sec_Q95KVeW9RG8w227CEONjo525t96nmyigzygygy9202407211509126964774f428egu1x3bttOY7n5&lt;G* ---md5-&gt; b8df766f084d15a71eb7422a2c999137 b8df766f084d15a71eb7422a2c999137appid:pc_home_page&amp;client:pc&amp;clientVersion:1.0.0&amp;functionId:getAlwaysBuyGoods&amp;t:1721545191402b8df766f084d15a71eb7422a2c9991377n5&lt;G* --&gt;md5-&gt; 810c4f5c06a1307bc27490e3ffe80fcf 总的来说 第五段的生成 是第四段token拼接第二段 在拼接第一段在拼接4774f428egu1x3bttOY加上salt值7n5&lt;G* 生成md5值后 按键值对大小拼接body中的appid和client和clientVersion和functionid和t,最后在拼接一下生成的md5值和salt值7n5&lt;G*生成的结果即为第五段结果 至于 4774f428egu1x3bttOY 怎么来的，还没能研究透彻，但多次测试发现是固定的，可能与个人账号有关。 algo:function test(tk,fp,ts,ai,algo){var rd=&#39;IuxIY6nBYZ8r&#39;;var str=&quot;&quot;.concat(tk).concat(fp).concat(ts).concat(ai).concat(rd);return algo.HmacMD5(str,tk);} 现在发现 47是固定的 而 74f42是appid即第三段 8egu1x3bttOY是algo中的盐 即rd的值 如果请求参数带body 则需要把body进行sha256加密 然后带入第五段流程加密 第六段1版本号 4.7 第七段1与第一段相关 为时间戳 第八段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//aes加密 key =&#39;_M6Y?dvfN40VMF[X&#39;; iv =&#39;0102030405060708&#39;; //魔改了aes 自定义了几个方法用于base64的编码设置 v.Utils = { toWordArray: function(e) { for (var r = [], n = 0; n &lt; e.length; n++) r[n &gt;&gt;&gt; 2] |= e[n] &lt;&lt; 24 - n % 4 * 8; return t.lib.WordArray.create(r, e.length) }, fromWordArray: function(e) { for (var t = new Uint8Array(e.sigBytes), r = 0; r &lt; e.sigBytes; r++) t[r] = e.words[r &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - r % 4 * 8 &amp; 255; return t } }; //一段jsvmp _append: function(e) { for (var t, r, n = c, a = i, o = [], l = 0; ; ) switch (a[l++]) { case 6: t = o[o.length - 1]; break; case 13: o.push(this); break; case 21: o.push(k); break; case 32: o.push(o[o.length - 1]); break; case 35: e = o[o.length - 1]; break; case 36: o[o.length - 2][s[a[l++]]] = o[o.length - 1], o[o.length - 2] = o[o.length - 1], o.length--; break; case 41: return; case 45: o.push(a[l++]); break; case 49: r = o.pop(), o[o.length - 1] += r; break; case 57: o.push(e); break; case 60: o.push(null); break; case 66: o[o.length - 1] = o[o.length - 1][s[a[l++]]]; break; case 67: o.push(t); break; case 69: o[o.length - 1] = Dg(o[o.length - 1]); break; case 72: o.pop(); break; case 73: o[o.length - 1] ? (++l, --o.length) : l += a[l]; break; case 75: o.push(o[o.length - 1]), o[o.length - 2] = o[o.length - 2][s[a[l++]]]; break; case 80: r = o.pop(), o[o.length - 1] = o[o.length - 1] == r; break; case 90: null != o[o.length - 2] ? (o[o.length - 3] = n.call(o[o.length - 3], o[o.length - 2], o[o.length - 1]), o.length -= 2) : (r = o[o.length - 3], o[o.length - 3] = r(o[o.length - 1]), o.length -= 2); break; case 95: o.push(u) } }, /*我们插装发现 他翻转了密钥 X[FMV04Nfvd?Y6M_ 其实这个aes整体并没做太大的魔改，只是把密钥给反转了而已，算法是原生的aes 主要魔改了base64算法 才使其加密的结果不同*/ //魔改base64算法 我们把所有运算符的操作给打上日志点，根据规律慢慢还原。 encode: function (t) { let r = e.enc.Utils.fromWordArray(t) let array = new Array(0) let n = array.slice.apply(r) let a = new Array(0) Array.prototype.push.apply(a, n) for (let o = 3 - a.length % 3, u = 0; u &lt; o; u++) { a.push(o) } let l = new Array(0) for (let i = a.length - 1; i &gt;= 0; i = i - 3) { a.slice(i - 2, i + 1) Array.prototype.push.apply(l, a.slice(i - 2, i + 1)) } let f = e.enc.Utils.toWordArray(l) let g = f.words let p = f.sigBytes let v = this._map1 f.clamp(f) let d = new Array(0) for (let b = 0; b &lt; p; b += 3) { let y = g[b &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - b * 8) &amp; 255 let k = g[(b + 1) &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (b + 1) * 8) &amp; 255 let m = g[(b + 2) &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (b + 2) * 8) &amp; 255 let w = y &lt;&lt; 16 | k &lt;&lt; 8 | m for (let _ = 0; _ &lt; 4; _++) { if ((b + (_ * 0.75)) &lt; p) { d.push(v.charAt((w &gt;&gt;&gt; 6 * (3 - _) &amp; 63))) } } } let x = [] for (let j = 0; j &lt; d.length; j += 4) { x.push.apply(x, d.slice(j, j + 4).reverse()) } return x.join(&quot;&quot;) } 第九段12345678tk03wbb161bb218ny47exhUsIoE3D7lHbxbZgTik7YqisIFvWjBTQG8XlY2fmxSJ5sec_Q95KVeW9RG8w227CEONjo525t96nmyigzygygy9202407211245081744774f428egu1x3bttOY7n5&lt;G* --&gt; a1957d7fbdd8687cc8a075743aae865a a1957d7fbdd8687cc8a075743aae865aappid:pc_home_page&amp;functionId:getAlwaysBuyGoodsa1957d7fbdd8687cc8a075743aae865a7n5&lt;G* ---&gt;4b8b4c86155f61276e7a8df6ffc8dcdc 现在发现 47是固定的 而 74f42是appid即第三段 8egu1x3bttOY是algo中的盐 所以第8段的加密即为 第五段tk拼接第二段拼接第一段拼接4774f428egu1x3bttOY在拼接7n5&lt;G* 得到的md5值 md5值拼接body中的appid值在拼body中的functionId值在拼接md5值在拼接7n5&lt;G* 就得到了第9段的md5值 与第五段比较相近 但不用的在于 第八段之只用到了body中的appid和fucntionid这两个参数。 请求也是问题不大 一些坑点要想实现接口部署还需要部分细节修饰 algo12345对于algo 主要有一个expandParams的参数问题 他和第七段一样也是个aes。主要问题在于他的key不同于第七段 是 wm0!@w-s#ll1flo( 加密参数是 &#39;{\\n &quot;wc&quot;: 0,\\n &quot;wd&quot;: 0,\\n &quot;l&quot;: &quot;zh-CN&quot;,\\n &quot;ls&quot;: &quot;zh-CN,en,en-GB,en-US&quot;,\\n &quot;ml&quot;: 2,\\n &quot;pl&quot;: 2,\\n &quot;av&quot;: &quot;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36 Edg/127.0.0.0&quot;,\\n &quot;ua&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36 Edg/127.0.0.0&quot;,\\n &quot;sua&quot;: &quot;Macintosh; Intel Mac OS X 10_15_7&quot;,\\n &quot;pp&quot;: {\\n &quot;p2&quot;: &quot;桥到船头自然沉9060&quot;\\n },\\n &quot;extend&quot;: {\\n &quot;wd&quot;: 0,\\n &quot;l&quot;: 0,\\n &quot;ls&quot;: 2,\\n &quot;wk&quot;: 0,\\n &quot;bu1&quot;: &quot;0.1.5&quot;,\\n &quot;bu2&quot;: 0,\\n &quot;bu3&quot;: 50,\\n &quot;bu4&quot;: 0,\\n &quot;bu5&quot;: 0,\\n &quot;bu6&quot;: 10\\n },\\n &quot;pp1&quot;: &quot;&quot;,\\n &quot;w&quot;: 1728,\\n &quot;h&quot;: 1117,\\n &quot;ow&quot;: 1728,\\n &quot;oh&quot;: 992,\\n &quot;url&quot;: &quot;https://paipai.m.jd.com/ppdbd/pages/detail/index?id=389626893&amp;cprice=47&amp;entryid=p0020003hd190531&amp;showhead=no&amp;entryid=p0020003hd190531&amp;scene=null&quot;,\\n &quot;og&quot;: &quot;https://paipai.m.jd.com&quot;,\\n &quot;pf&quot;: &quot;MacIntel&quot;,\\n &quot;pr&quot;: 2,\\n &quot;re&quot;: &quot;&quot;,\\n &quot;random&quot;: &quot;UhHAH4rSHNTC&quot;,\\n &quot;referer&quot;: &quot;&quot;,\\n &quot;v&quot;: &quot;h5_file_v4.7.4&quot;,\\n &quot;bu2&quot;: &quot; at https://storage.360buyimg.com/webcontainer/js_security_v3_0.1.5.js:3833:21&quot;,\\n &quot;canvas&quot;: &quot;fa3fabf83a3dc96ca518dcdec635e8d9&quot;,\\n &quot;webglFp&quot;: &quot;e3873b69ce54d5eb4893fad2d0592dda&quot;,\\n &quot;ccn&quot;: 14,\\n &quot;ai&quot;: &quot;86b9f&quot;,\\n &quot;fp&quot;: &quot;n5yi5yn5ytzg69i1&quot;\\n}&#39; 主要是ai 也就是appid 和fp 的处理问题就可以实现动态请求 random其实可以处理可以不处理","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"qqsign jsvmp算法还原","slug":"逆向/jsvmp-QQ音乐sign","date":"2024-08-23T04:40:22.000Z","updated":"2024-09-21T11:13:28.260Z","comments":true,"path":"2024/08/23/逆向/jsvmp-QQ音乐sign/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/08/23/%E9%80%86%E5%90%91/jsvmp-QQ%E9%9F%B3%E4%B9%90sign/","excerpt":"","text":"jsvmp-qq 音乐入口处直接搜 sign 打断点就好了 就定位到这个地方。 t.data 是加密的 params 进入 o，印入眼帘的则是 jsvmp 了 直接在 switch 处打上断电，猛梭就完事了。 输出的是 d 这个数组。 我们在上文中看到了一些 sha1 中的 4 轮运算的值 所以大胆猜测一下，他对我们的加密的字符串 params 做了 sha1 的加密操作，所以我们带到一个网站去加密然后验证一下 所以直接从 sha1 值第一处的往下分析。 有时间在讲吧，下面就是对 switch 插装 &#39;索引&#39;,n[g+1],g+1,&#39;值&#39;,console.log(d) call 地方打索引断点 。 贴出代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var aaa = [23, 14, 6, 36, 16, 40, 7, 19]; var bbb = [16, 1, 32, 12, 19, 27, 8, 5]; var ccc = [ 89, 39, 179, 150, 218, 82, 58, 252, 177, 52, 186, 123, 120, 64, 242, 133, 143, 161, 121, 179, ]; var string_to_num = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, }; var b64str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;; var data_Sha1 = &quot;e3b7e88c5178c77fec1228baf2d8515f81e8809e&quot;.toUpperCase(); var stra = aaa .map((x) =&gt; { return data_Sha1.charAt(x); }) .join(&quot;&quot;); console.log(&quot;first&quot;, stra); var strb = bbb .map((x) =&gt; { return data_Sha1.charAt(x); }) .join(&quot;&quot;); console.log(&quot;last&quot;, strb); var result_arr = []; for (let i = 0; i &lt; 2 * ccc.length; i++) { var a1 = data_Sha1[i], a2 = data_Sha1[i + 1], b1 = string_to_num[a1], b2 = string_to_num[a2], c = ccc[i / 2], result = (b1 * 16) ^ b2 ^ c; result_arr.push(result); i++; } console.log(result_arr); console.log(result_arr.length); console.log(String.fromCharCode(...result_arr)); // /[+=]+$/ var str_medium = btoa(String.fromCharCode(...result_arr)).replace( /\\+|=+$/g, &quot;&quot; ); console.log(&quot;str_medium&quot;, str_medium.toLowerCase()); result_str = (&quot;zzc&quot; + stra + str_medium + strb).toLowerCase(); console.log(result_str);","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-08-23T03:25:04.899Z","updated":"2024-08-23T03:25:04.899Z","comments":true,"path":"2024/08/23/hello-world/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/08/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"验证码识别","slug":"验证码识别","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"},{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]}