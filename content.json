{"meta":{"title":"skuukzky","subtitle":"眠","description":"","author":"skuukzky","url":"https://lpy30m.github.io/skuukzky.github.io","root":"/skuukzky.github.io/"},"pages":[{"title":"朋友","date":"2024-08-23T04:00:00.000Z","updated":"2024-08-28T06:25:36.036Z","comments":true,"path":"PY.html","permalink":"https://lpy30m.github.io/skuukzky.github.io/PY.html","excerpt":"","text":"今诸生学于太学，县官日有廪稍之供，父母岁有裘葛之遗，无冻馁之患矣；坐大厦之下而诵诗书，无奔走之劳矣；有司业、博士为之师，未有问而不告，求而不得者也；凡所宜有之书，皆集于此，不必若余之手录，假诸人而后见也。其业有不精，德有不成者，非天质之卑，则心不若余之专耳，岂他人之过哉！ 使用网站 朋友每次编译时，随机排序 添加友链你可以直接编辑：https://github.com/nexmoe/nexmoe.com/edit/main/source/PY.md 也可以使用如下格式方便懒狗我复制粘贴 123456{ &quot;title&quot;: &quot;折影轻梦&quot;, &quot;link&quot;: &quot;https://nexmoe.com&quot;, &quot;img&quot;: &quot;https://cravatar.cn/avatar/c7fd185f8c967dec20c29c75a40b9e09?s=500&quot;, &quot;des&quot;: &quot;为热爱战斗着，努力学着变得勇敢&quot; }"},{"title":"关于","date":"2024-08-23T04:14:22.573Z","updated":"2024-08-23T04:14:22.573Z","comments":true,"path":"about.html","permalink":"https://lpy30m.github.io/skuukzky.github.io/about.html","excerpt":"","text":"我是谁导航"},{"title":"文章归档","date":"2024-08-23T04:09:57.710Z","updated":"2024-08-23T04:09:53.839Z","comments":true,"path":"archive.html","permalink":"https://lpy30m.github.io/skuukzky.github.io/archive.html","excerpt":"","text":""},{"title":"","date":"2024-09-27T14:33:32.526Z","updated":"2024-09-27T14:33:32.526Z","comments":true,"path":"custom.css","permalink":"https://lpy30m.github.io/skuukzky.github.io/custom.css","excerpt":"","text":":root { --color-shadow: rgb(204 177 161 / 60%); } body { overflow-x: hidden; } #nexmoe-content .nexmoe-post-footer { background-color: transparent; } iframe { width: 100% !important; } article ul li { line-height: 1.5rem; } [data-theme=\"light\"] { --hl-color: #90a4ae !important; --hl-bg: #f6f8fa !important; --hltools-bg: #e6ebf1 !important; --hltools-color: #90a4ae !important; --hlnumber-bg: #f6f8fa !important; --hlnumber-color: rgba(144, 164, 174, 0.5) !important; --hlscrollbar-bg: #dce4eb !important; --hlexpand-bg: linear-gradient(180deg, rgba(246, 248, 250, 0.1), rgba(246, 248, 250, 0.9)) !important; } [data-theme=\"dark\"] { --hl-color: #abb2bf !important; --hl-bg: #282c34 !important; --hltools-bg: #21252b !important; --hltools-color: #bbbbbc !important; --hlnumber-bg: #282c34 !important; --hlnumber-color: #495162 !important; --hlscrollbar-bg: #373c47 !important; --hlexpand-bg: linear-gradient(180deg, rgba(40, 44, 52, 0.1), rgba(40, 44, 52, 0.9)) !important; } figure.shiki { background-color: var(--hl-bg) !important; color: var(--hl-color) !important; }"},{"title":"赞助我","date":"2024-08-23T05:42:09.000Z","updated":"2024-08-23T05:42:10.472Z","comments":true,"path":"donate.html","permalink":"https://lpy30m.github.io/skuukzky.github.io/donate.html","excerpt":"","text":"还是留给自己买 kfc 吧"}],"posts":[{"title":"TikTok-验证码hashcash之answer参数分析","slug":"验证码识别/TikTok-验证码hashcash之answer参数分析","date":"2025-05-15T07:20:45.000Z","updated":"2025-05-15T07:40:06.764Z","comments":true,"path":"2025/05/15/验证码识别/TikTok-验证码hashcash之answer参数分析/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2025/05/15/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/TikTok-%E9%AA%8C%E8%AF%81%E7%A0%81hashcash%E4%B9%8Banswer%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/","excerpt":"","text":"TikTok-验证码hashcash之answer参数分析前言在游客状态下，访问用户主页，可能会有概率触发hashcash的旋转类型滑块，他与旋转不通，多了一个answer的函数，其他轨迹和参数大致相同，此处分析answer参数，堆栈得知是个jsvmp。 分析插桩apply函数调用和 + - * / % ^ * &gt;&gt; &lt;&lt; 运算符 示例如下 &quot;对象E: &quot;, JSON.stringify(E,function(k, v) &#123;if (v === window) &#123;return &#39;window&#39;&#125; return v&#125;), &quot;函数w: &quot;, w.toString(), &quot;参数_: &quot;, JSON.stringify(_,function(k, v) &#123;if (v === window) &#123;return &#39;window&#39;&#125; return v&#125;), &quot;结果k: &quot;, k &#39;p[d]&#39;,p[d] ,&#39;+=&#39; ,&#39;t&#39;,t 观察日志发现 1234567891011121314151617181920212223242526272829303132333435363738394041424344创建 [0,0,0,0,0,0,0,0] 生成 8个随机数 * 固定 9007199254740992 *= t 9007199254740992 然后拼接得到一个数组 数组1 = [48,4,31,33,10,10,4,28] 时间戳 = 1747289062 stamp = 2882356194 临界值= stamp &gt;&gt;&gt; 24 = 171 &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; 字符串根据上面数组1 charAt 后得到WeFHkkeC 拼接时间戳得到 1747289062WeFHkkeC 现在经过一个已知函数hashFunction 得到726972017 现在根据726972017来计算 第一步 726972017 &gt;&gt;&gt; 24 = 43 24位固定值 43 ^ 171 = 128 171是上述临界值 128结果无用，后续经过了一个log2函数，发现没用用到结果，暂时当作临界值判断。 现在取出 数组1第一位 48 48 += 1 = 49 1位固定值 49 %= t 52 = 49 现在得到49 ,然后替换列表第一位得到 数组2 = [49,4,31,33,10,10,4,28] 数组2同上操作 数组2 charAt 后得到 XeFHkkeC 拼接时间戳 1747289062XeFHkkeC 进入hashFunction得到-227236643 -227236643 &gt;&gt;&gt; 24 = 242 24位固定值 242 ^ 171 = 89 171是上述临界值 现在取出 数组2第一位 49 49 += 1 = 50 1位固定值 50 %= t 52 = 50 根据此规律运行，然后有个条件当数组的第一位大于52时候 即 [51,4,31,33,10,10,4,28] 第一位清0 然后数组1第二位加1 继续重复运算 [0,5,31,33,10,10,4,28] 如果当运算时, [17,5,31,33,10,10,4,28] -1423261474 &gt;&gt;&gt; 24 = 171 结果与临界值相等时，停止运算，切获得最后的结果 即为 &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; charAt [17,5,31,33,10,10,4,28] 后得到rfFHkkeC 理清楚逻辑，交给gpt完成代码 结果","categories":[{"name":"验证码识别","slug":"验证码识别","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"}],"tags":[]},{"title":"Tiktok X-Gnarly jsvmp算法还原","slug":"逆向/Tiktok-X-Gnarly-jsvmp算法还原","date":"2025-04-26T06:12:13.000Z","updated":"2025-04-26T06:40:06.796Z","comments":true,"path":"2025/04/26/逆向/Tiktok-X-Gnarly-jsvmp算法还原/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2025/04/26/%E9%80%86%E5%90%91/Tiktok-X-Gnarly-jsvmp%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F/","excerpt":"","text":"Tiktok X-Gnarly jsvmp算法还原导言前几天偶然在群里看到一个github仓库 具体内容大家可以自行看看，总的内容就是对tk的vmpwebmssdk.js进行去混淆和反编译，但当我查看的时候，tk已经进行了更新，并且还多出来了一个X-Gnarly的参数，我功力不够，无法对新版本的进行VM虚拟机的还原，所以本篇文章就只能用千篇一律的插桩和分析进行逆向还原了，如果有高手能够还原VM，期待你的文章。 分析虽然，无法还原VM，但是去混淆的思路，还是可以借用他的。 附上Deepseek和仓库原作者的还原思路后的AST代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091const fs = require(&#39;fs&#39;); const path = require(&#39;path&#39;); const parser = require(&#39;@babel/parser&#39;); const traverse = require(&#39;@babel/traverse&#39;).default; const t = require(&#39;@babel/types&#39;); const generator = require(&#39;@babel/generator&#39;).default; // 输入输出配置 const inputPath = &#39;./ems1.js&#39;; const outputPath = &#39;./output.js&#39;; // 读取源代码 const code = fs.readFileSync(inputPath, &#39;utf-8&#39;); // 解析AST const ast = parser.parse(code, { sourceType: &#39;unambiguous&#39;, plugins: [&#39;jsx&#39;] }); const functionMap = new Map(); // ========== 第一步：提取yg数组中的匿名函数，替换为具名引用，并在就地插入具名函数声明 ========== traverse(ast, { VariableDeclarator(path) { if ( t.isIdentifier(path.node.id, { name: &#39;yg&#39; }) &amp;&amp; t.isArrayExpression(path.node.init) ) { const elements = path.node.init.elements; const insertions = []; elements.forEach((element, index) =&gt; { if (t.isFunctionExpression(element) || t.isArrowFunctionExpression(element)) { const funcName = `Ab${index}`; const funcDeclaration = t.functionDeclaration( t.identifier(funcName), element.params, t.isBlockStatement(element.body) ? element.body : t.blockStatement([t.returnStatement(element.body)]), element.generator, element.async ); functionMap.set(index, funcName); // 替换数组中的函数为具名函数标识符 elements[index] = t.identifier(funcName); // 保存要插入的位置和内容 insertions.push(funcDeclaration); } }); // 在当前 VariableDeclaration 后面插入所有函数声明 const declPath = path.findParent(p =&gt; p.isVariableDeclaration()); insertions.reverse().forEach(fn =&gt; { declPath.insertAfter(fn); // 就地插入每个函数定义 }); } } }); // ========== 第二步：替换yg[索引](args) 为 AbX(args) ========== traverse(ast, { CallExpression(path) { const callee = path.node.callee; if ( t.isMemberExpression(callee) &amp;&amp; t.isIdentifier(callee.object, { name: &#39;yg&#39; }) &amp;&amp; t.isNumericLiteral(callee.property) ) { const index = callee.property.value; if (functionMap.has(index)) { path.node.callee = t.identifier(functionMap.get(index)); } } } }); // ========== 生成最终代码 ========== const output = generator(ast, { retainLines: false, comments: true, jsescOption: { minimal: true } }).code; fs.writeFileSync(outputPath, output); console.log(&#39;✅ 处理完成，函数已就地替换！&#39;); 这个时候，我们去代码中搜索X-Gnarly xn是XB.On是XG,所以我们全局搜索 On看看哪里进行了调用，顺便也看看附近有没有xn ，方便我们定位到，我们在把解混淆后的放入网页中替换。一共两处，然后打上断点触发，这里断住了，我们分析参数， 12345a = bn(i, t)), i：&#39;WebIdLastTime=1742522342&amp;aid=1988&amp;app_language=zh-Hans&amp;app_name=tiktok_web&amp;browser_language=zh-CN&amp;browser_name=..... (太长省略)&#39; t: &quot;&quot; (Get请求) t:{&quot;magic&quot;:538969122,&quot;version&quot;:1,&quot;dataType&quot;:8,&quot;strData&quot;:&quot;38NyodcW9CLhuMe299J/... 和Xb差不多，此请求是Get。所以请求i是params，t是&quot;&quot;，如果是Get，则i是参数，t是data 显然就是bn函数生成了，进入bn函数，然后发现是Ab9函数,上下浏览关键的就是这个do循环 在进入h函数就已经是经典的jsvmp桥段了。 插桩插桩可以看这两篇文章JS逆向技巧：日志断点如何正确输出 JSON 而不报错 【逆向案例】巨量算数响应体vmp-decode 正巧的是第二篇文章和tk一样同为字节开发的，插桩流程也是一样。 1234567(H = W[&quot;apply&quot;](V, Q),v[++l] = H) &quot;对象V: &quot;, JSON.stringify(V,function(k, v) {if (v === window) {return &#39;window&#39;} return v}), &quot;函数W: &quot;, W.toString(), &quot;参数Q: &quot;, JSON.stringify(Q,function(k, v) {if (v === window) {return &#39;window&#39;} return v}), &quot;结果H: &quot;, H H = new (Function.bind[&quot;apply&quot;](B, z))(); &quot;函数B: &quot;, B.toString(), &quot;参数z: &quot;, JSON.stringify(z), 结果H: &quot;, H JSON.stringify(V,function(k, v) {if (v === window) {return &#39;window&#39;} return v}) 还原先从上到下观察浏览器日志， 发现这里应该是环境检测，格式化检测和自动化检测，下面还有环境检测很多，继续观察。 这里发现了一些东西，3个32位的值(？md5)和时间戳获取，时间戳肯定是毋庸置疑，我们看一下这3个东西是否为md5，可以看到就在上面，经过一个匿名函数，我们放入CyberChef验证一下,依次验证发现分别对应的是,url后缀params的md5和参数data的md5和user-agent的md5 继续查看 这里看到他在push数组，而这4个数组是什么呢，我们看到了 一个关键函数 setUint16() 如果你还不是明白可以问Deepseek或者朋友，这里我去请教了下福生大佬啊，他直接一眼顶真 告诉我这是 Uint8Array 接着问了下gpt 的确如此啊，然后让他转一下方法 就出来了 1234567891011121314151617181920function uInt32sToBytesLE(uint32Array) { const resultBytes = []; for (const value of uint32Array) { // 为每个 32 位整数创建 4 字节的缓冲区 const buffer = new ArrayBuffer(4); const dataView = new DataView(buffer); // 按小端序写入整数 dataView.setUint32(0, value, false); // 提取字节并合并到结果数组 resultBytes.push(...new Uint8Array(buffer)); } return resultBytes; } // 测试数据 var e = [556645436] // 转换为字节数组 const array_test_two = uInt32sToBytesLE(e); console.log(array_test_two); 这里的e也就是图中的 [&#123;&quot;0&quot;:556645436,&quot;1&quot;:1,&quot;2&quot;:14,&quot;3&quot;:&quot;c20e522f3995433f755e282ec81bb40a&quot;,&quot;4&quot;:&quot;7226faf67640367ae589dea1020b0ab9&quot;,&quot;5&quot;:&quot;1b04588d93b1afac45573a43b9e15594&quot;,&quot;6&quot;:1745638813,&quot;7&quot;:1245783967,&quot;8&quot;:56675889,&quot;9&quot;:&quot;5.1.0&quot;&#125;]中的0元素。 继续查看 这里也把url的md5值转Uint8Array也push进数组，剩下就是相同操作了,把上文中数据全部按此操作加入到数组中，最后的得到push完的数组了。 继续查看，发现在把这个数组利用fromCharCode专为字符串。也就是后文中的第一个乱码字符串。 继续查看他这里在取随机数* 固定值 4294967296 在进Math.floor之后 继续转Uint8Array 12345function generateRandomIntegers() { return Array.from({ length: 12 }, () =&gt; Math.floor(Math.random() * 4294967296) ); } 这里说一下经过函数Ab22的几个参数 第一个上文根据随机数相乘后得到的12个数组，第二个是16暂时我们不知道，第三个参数就是我们152数组转字符串的，最后结果得到是一个乱码。 Ab22现在我们来探寻一下这个16是什么怎么来的， 来到函数h的部分，在这里打上日志 e,c,JSON.stringify(v) 在Ab22函数中打上断点，防止日志过多， 现在我们观察这个14是怎么来的就好了，现在一步步往上追，这里不带着一步步追了，单看一个部分，就能理解了 我们发现在日志上，他都是和我们这12位数组相关的，这里我是倒着看 截取一些日志 1234567891011121314首先通读一遍. 看到了15 46 74 &#39;[3737565922,15,3737565922,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 在经过下一步运算且就多了2 还是有个15 49 75 &#39;[2,15,3737565922,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 且有了个14,也不清楚怎么来的 21 78 &#39;[2,14,3737565922,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 然后有了个16，应该是2+14来的，14应该是上文的14 5 79 &#39;[16,14,3737565922,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 还是有个15 不清楚怎么来的 46 81 &#39;[16,15,3737565922,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 这里多出来了个0 71 82 &#39;[0,15,3737565922,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 49 85 &#39;[0,15,3737565922,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 我们先解决最容易解决的 3737565922,15 是怎么变成2的 我的建议是在各种运算符中插上运算，方便你更好的观察。 这里不卖关子，3737565922&amp;15 是进行&amp;变成了2 多进行几次日志的保存可以发现 15是固定的，那么就可以有个猜测，凡是第二位是15的基本都是要进行&amp;操作的 那这个12呢，其实一共有12个数组，这里是一小部分，往上查找一下，12其实是上一个整体运算得到的结果， 那么16 应该就是 14+2 (3737565922&amp;15) +2(前面的 2 &amp;15 )了 那么16,15是怎么变成0的呢？ 其实还是和上面一个道理 16&amp;15 那么其实整体就明白了 数组一中的 3737565922 &amp;15 = 2 加上&amp;后的结果上文的 14 结果&#x3D; 16 &amp; 15 &#x3D; 0 这里听着可能迷糊 再来一组就好 1234567891046 74 &#39;[3624428041,15,3624428041,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 3624428041 &amp; 15 = 9 49 75 &#39;[9,15,3624428041,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 9 &amp;15 = 9 0上上文运算的0 21 78 &#39;[9,0,3624428041,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 9+0 = 0 5 79 &#39;[9,0,3624428041,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 46 81 &#39;[9,15,3624428041,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 9&amp; 15 = 9 71 82 &#39;[9,15,3624428041,4294967296,null,2,32,[7,1245783967],[8,1640124884],[9,&quot;5.1.0&quot;],&quot;5.1.0&quot;,&quot;$chrome_asyncScriptInfo&quot;,&quot;__$webdriverAsyncExecutor&quot;]&#39; 上面我已经附上了各种运算结果，最后要注意的是，如果你插桩+&#x3D;这个，他的结果每次都会在+5 就是最终的结过，得到这个思路后，把它复述给gpt,让他帮我们完成代码。 1234567891011const array = [3447926452,2069153462,3972284619,4133534163,3678609889,97836732,1914591165,4045946446,1756250425,147771365,3737565922,3624428041] const FIXED = 4294967296; let n = FIXED &amp; 15; // 初始值为 0 for (let i = 0; i &lt; array.length; i++) { const current = array[i] &amp; 15; n = (current + n) &amp; 15; res = n+5; } console.log(&quot;最终结果是:&quot;, res); // 输出：13 也是和网页上对的上的 继续查看，这次我们从这个生成的乱码字符串入手，会简单很多，直接搜索，然后定位最后一个，这里我们发现他多了个K 可能是拼接的salt，毕竟xb也有拼接，并不奇怪，这里我们搜索开头，把K也加进入进去， 往上翻翻看到了一个substring函数的切割，还看到他把48位数组，就是我们Uint8array转的那些随机数，也进行了转字符串， 也就是”K”+前91位切断+48数组转的字符串+后91位 代码如下。 123456789101112131415161718192021array_test = [10,0,0,4,67,143,22,187,1,0,2,0,1,2,0,2,0,14,3,0,32,99,97,53,99,53,57,51,55,97,98,54,49,98,51,57,98,97,51,55,97,56,57,49,102,99,50,99,55,57,54,97,97,4,0,32,100,52,49,100,56,99,100,57,56,102,48,48,98,50,48,52,101,57,56,48,48,57,57,56,101,99,102,56,52,50,55,101,5,0,32,49,98,48,52,53,56,56,100,57,51,98,49,97,102,97,99,52,53,53,55,51,97,52,51,98,57,101,49,53,53,57,52,6,0,4,104,12,96,255,7,0,4,74,65,39,159,8,0,4,97,194,81,212,9,0,5,53,46,49,46,48] const array_test_two =[180,46,131,205,182,198,84,123,203,64,196,236,211,185,96,246,225,33,67,219,188,222,212,5,189,87,30,114,78,62,40,241,57,65,174,104,229,207,206,8,226,186,198,222,9,98,8,216] const grable_string = String.fromCharCode(...array_test); const grable_string_two = String.fromCharCode(...array_test_two); console.log(&quot;grable_string&quot;, grable_string.length) console.log(&quot;grable_string_two&quot;, grable_string_two.length) var e = [3447926452,2069153462,3972284619,4133534163,3678609889,97836732,1914591165,4045946446,1756250425,147771365,3737565922,3624428041] garbled_characters = Ab22(e, 14, grable_string); console.log(garbled_characters) console.log(&quot;111&quot;,garbled_characters.charCodeAt(0)) sub1 = garbled_characters.substring(0, 110) // substring 是动态 sub2 = garbled_characters.substring(110) console.log(sub1) const final_str = &#39;K&#39; + sub1 + grable_string_two + sub2 console.log(final_str) // ModiB64 魔改base64和xb一样，只是码表不同而已。 const x_Gnarly = ModiB64(&quot;u09tbS3Uxxxxx(脱敏)k8JORCF5/xKHwacP=&quot;, final_str) console.log(x_Gnarly) 发现结果是完全对的上的，只剩下substring的值 ，是怎么取得了。 substring取值这里纯看日志，插桩+&#x3D; 和 %&#x3D;就可以分析出来 在(H = W[&quot;apply&quot;](V, Q), 下个条件断点 W.toString() == &#39;function substring() &#123; [native code] &#125;&#39; 插桩就可以了 截取部分日志 12345678910111213141516171819202122232425数组一 = [102,126,80,64,182,9,42,92,254,191,247,183,160,220,98,203,210,35,70,109,222,49,40,131,199,209,86,193,8,149,142,203,226,179,177,113,167,115,41,237,177,184,53,124,112,13,216,87] 数组二 = [148,63,67,189,6,17,96,154,48,195,123,175,103,47,188,168,187,192,207,60,61,254,143,103,48,95,64,160,120,59,115,205,225,61,2,255,194,46,253,224,177,157,162,130,129,20,13,125,47,137,51,173,247,243,70,5,239,66,29,246,93,219,218,97,1,124,54,244,130,134,255,23,227,165,57,16,188,192,205,40,224,98,138,147,251,50,189,220,10,93,74,41,99,160,36,22,23,171,160,252,63,156,154,105,5,43,191,108,46,205,24,62,202,244,38,161,11,73,7,0,118,252,204,190,177,169,195,165,37,204,67,74,121,172,154,118,32,247,121,136,223,79,242,214,41,179,158,253,129,96,25,82] 现在根据我的下文的提示帮我编写js代码 //数组一 48位数组 v[l] 0 += n 102 0是固定值 v[l] 152 += n 1 153 固定153 v[l] 102 %= n 153 102 %153= 102 v[l] 102 += n 126 上个结果中的102 + 数组中的第二位 126 = 228 v[l] 152 += n 1 153 固定153 v[l] 228 %= n 153 228 % 153 = 75 v[l] 75 += n 80 v[l] 152 += n 1 v[l] 155 %= n 153 v[l] 2 += n 64 v[l] 152 += n 1 v[l] 66 %= n 153 v[l] 66 += n 182 v[l] 152 += n 1 v[l] 248 %= n 153 //然后数组二也是同理 数组二是152位数组 同样，把需求整理给Gpt，让他给出代码。 123456789101112131415161718192021222324252627282930313233343536 arrays = [] function loopStringChars(str) { for (let i = 0; i &lt; str.length; i++) { const char = str.charCodeAt(i); // 或直接用 str[i] //console.log(`位置 ${i} 的字符: ${char}`); arrays.push(char) } return arrays } array_test = [10,0,0,4,67,143,22,187,1,0,2,0,1,2,0,2,0,14,3,0,32,99,97,53,99,53,57,51,55,97,98,54,49,98,51,57,98,97,51,55,97,56,57,49,102,99,50,99,55,57,54,97,97,4,0,32,100,52,49,100,56,99,100,57,56,102,48,48,98,50,48,52,101,57,56,48,48,57,57,56,101,99,102,56,52,50,55,101,5,0,32,49,98,48,52,53,56,56,100,57,51,98,49,97,102,97,99,52,53,53,55,51,97,52,51,98,57,101,49,53,53,57,52,6,0,4,104,12,96,255,7,0,4,74,65,39,159,8,0,4,97,194,81,212,9,0,5,53,46,49,46,48] const grable_string = String.fromCharCode(...array_test); var e = [3447926452,2069153462,3972284619,4133534163,3678609889,97836732,1914591165,4045946446,1756250425,147771365,3737565922,3624428041] garbled_characters = Ab22(e, 14, grable_string); console.log(garbled_characters) 数组一 = loopStringChars(garbled_characters) console.log(数组一) 数组二 = [180,46,131,205,182,198,84,123,203,64,196,236,211,185,96,246,225,33,67,219,188,222,212,5,189,87,30,114,78,62,40,241,57,65,174,104,229,207,206,8,226,186,198,222,9,98,8,216] let v = 0; // 处理数组一 for (const num of 数组一) { v += num; v %= 153; } // 处理数组二 for (const num of 数组二) { v += num; v %= 153; } console.log(v); 结尾代码整合运行 一级评论 二级评论 目前整个X-Gnarly就分析完毕了，整体逆向还是很艰辛，感谢有福生大佬，对我进行教学指导，不然靠自己还是过于吃力。","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"抖音滑块分析","slug":"验证码识别/抖音滑块分析","date":"2025-03-13T07:31:28.000Z","updated":"2025-03-13T07:49:55.546Z","comments":true,"path":"2025/03/13/验证码识别/抖音滑块分析/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2025/03/13/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E6%8A%96%E9%9F%B3%E6%BB%91%E5%9D%97%E5%88%86%E6%9E%90/","excerpt":"","text":"抖音滑块分析代码插装在堆栈中查看，其中有一处很明显的 captcha.js,应该是 captchabody 生成的关键 js，我们进入查看，整体预览 js 代码，发现 webpack+switch 控制流+vmp。接着查桩，先在 switch 处插桩，看看大概都做了什么。 switch 插装点 apply 插装点然后对于 vmp 这种，最好是在 call 和 apply 的地方下断点，这里 v(431)也是 apply，同理也插上断点。 日志分析这里我们进行验证码的提交，同时打下 xhr 断点，以防太多日志造成干扰和卡顿，然后观察日志。 然后这里放入 爬虫工具库 分析格式 这些参数分析下都是什么，首先有 id，是获取验证码图片的接口返回的，MMtJ2Xt 是验证码中点击的位置，v7VR5s 是鼠标在验证码图片里移动的轨迹和时间戳,env 包括了一些浏览器的环境。 接着往下查看日志。 这里看到了 sha-512 的字样，看样子是把 JSON.stringify 提交的参数进行了 sha-512 的加密。我们来验证一下是否为标准的算法。 符合我们的猜想且为标准的 sha-512 算法。继续看查看日志。 发现生成了个 32 位的随机数，最后用经过了一些算法在 join 成了一个字符串。然后同时也在进行 sha-512 发现他拼接了一个3c032864bb1f8479f92da1b57aa0553f36bb1ed83b2eab6c7ac9e8b08b50d518f444d4b6d2261f158b2ad27a72f804f058fcb31ba1404cdf78f63cb80ed86290然后又做了 sha-512 算法。这里可以多次断点触发几次，观察是固定的，应该是就是 salt 了。 那么就清楚了，流程应该是对随机生成的 32 位数字做 sha-512,拼接 salt，做 from hex 在进行 sha-512。我们这里验证一下。 没错，符合我们的猜想。 接着观察发现 对这加密后的结果进行了字符串切割取值 上图也能看到， 然后打断点分析下这里的代码，看到了 aes 的这样，猜测且上文分割的两个值很有可能是切分后的的 key 和 iv。 这里他转化成了 Uint8Array 的形式，我们查看内容，发现他是一部分乱码加明文的格式，明文很好理解，是我们最开始观察到的参数，而乱码是什么呢，我们可以去日志一搜，发现是我们明文格式的sha-512的结果，那么加密的内容应该就是如下操作 1234data = {&quot;modified_img_width&quot;:340,&quot;id&quot;:&quot;d3f7872be063c42ea4ea760d32dc46361a6a9f0e&quot;,&quot;mode&quot;:&quot;3d&quot;,&quot;MMtJ2Xt&quot;:[{&quot;x&quot;:213,&quot;y&quot;:136,&quot;time&quot;:1741830854441,&quot;t&quot;:0,&quot;relative_time&quot;:1741830854441},{&quot;x&quot;:261,&quot;y&quot;:161,&quot;time&quot;:1741830855008,&quot;t&quot;:0,&quot;relative_time&quot;:1741830855008}],&quot;JKWR&quot;:[],&quot;v7VR5s&quot;:{&quot;6Jbg&quot;:{&quot;x&quot;:266,&quot;y&quot;:303,&quot;time&quot;:1741830852841},&quot;MYE&quot;:{},&quot;AREm&quot;:[{&quot;x&quot;:378,&quot;y&quot;:300,&quot;time&quot;:1741830221614},{&quot;x&quot;:88,&quot;y&quot;:177,&quot;time&quot;:1741830221648},{&quot;x&quot;:293,&quot;y&quot;:207,&quot;time&quot;:1741830276079},{&quot;x&quot;:12,&quot;y&quot;:224,&quot;time&quot;:1741830410110},{&quot;x&quot;:12,&quot;y&quot;:224,&quot;time&quot;:1741830410181},{&quot;x&quot;:89,&quot;y&quot;:233,&quot;time&quot;:1741830410514},{&quot;x&quot;:265,&quot;y&quot;:226,&quot;time&quot;:1741830489006},{&quot;x&quot;:261,&quot;y&quot;:255,&quot;time&quot;:1741830489040},{&quot;x&quot;:252,&quot;y&quot;:296,&quot;time&quot;:1741830489074},{&quot;x&quot;:266,&quot;y&quot;:303,&quot;time&quot;:1741830852841},{&quot;x&quot;:245,&quot;y&quot;:224,&quot;time&quot;:1741830852877},{&quot;x&quot;:237,&quot;y&quot;:213,&quot;time&quot;:1741830852911},{&quot;x&quot;:229,&quot;y&quot;:206,&quot;time&quot;:1741830852945},{&quot;x&quot;:228,&quot;y&quot;:205,&quot;time&quot;:1741830853087},{&quot;x&quot;:241,&quot;y&quot;:235,&quot;time&quot;:1741830853121},{&quot;x&quot;:295,&quot;y&quot;:295,&quot;time&quot;:1741830853155},{&quot;x&quot;:353,&quot;y&quot;:303,&quot;time&quot;:1741830853189},{&quot;x&quot;:368,&quot;y&quot;:302,&quot;time&quot;:1741830853223},{&quot;x&quot;:368,&quot;y&quot;:302,&quot;time&quot;:1741830853375},{&quot;x&quot;:367,&quot;y&quot;:303,&quot;time&quot;:1741830853467},{&quot;x&quot;:365,&quot;y&quot;:300,&quot;time&quot;:1741830853501},{&quot;x&quot;:355,&quot;y&quot;:289,&quot;time&quot;:1741830853535},{&quot;x&quot;:311,&quot;y&quot;:245,&quot;time&quot;:1741830853569},{&quot;x&quot;:287,&quot;y&quot;:230,&quot;time&quot;:1741830853603},{&quot;x&quot;:278,&quot;y&quot;:222,&quot;time&quot;:1741830853637},{&quot;x&quot;:277,&quot;y&quot;:217,&quot;time&quot;:1741830853672},{&quot;x&quot;:277,&quot;y&quot;:216,&quot;time&quot;:1741830853711},{&quot;x&quot;:278,&quot;y&quot;:216,&quot;time&quot;:1741830853782},{&quot;x&quot;:280,&quot;y&quot;:218,&quot;time&quot;:1741830853816},{&quot;x&quot;:281,&quot;y&quot;:217,&quot;time&quot;:1741830853916},{&quot;x&quot;:281,&quot;y&quot;:217,&quot;time&quot;:1741830853955},{&quot;x&quot;:276,&quot;y&quot;:217,&quot;time&quot;:1741830853989},{&quot;x&quot;:269,&quot;y&quot;:215,&quot;time&quot;:1741830854023},{&quot;x&quot;:260,&quot;y&quot;:211,&quot;time&quot;:1741830854057},{&quot;x&quot;:253,&quot;y&quot;:210,&quot;time&quot;:1741830854092},{&quot;x&quot;:251,&quot;y&quot;:210,&quot;time&quot;:1741830854127},{&quot;x&quot;:250,&quot;y&quot;:209,&quot;time&quot;:1741830854165},{&quot;x&quot;:247,&quot;y&quot;:208,&quot;time&quot;:1741830854199},{&quot;x&quot;:241,&quot;y&quot;:205,&quot;time&quot;:1741830854233},{&quot;x&quot;:234,&quot;y&quot;:204,&quot;time&quot;:1741830854269},{&quot;x&quot;:234,&quot;y&quot;:204,&quot;time&quot;:1741830854497},{&quot;x&quot;:243,&quot;y&quot;:211,&quot;time&quot;:1741830854531},{&quot;x&quot;:258,&quot;y&quot;:219,&quot;time&quot;:1741830854565},{&quot;x&quot;:270,&quot;y&quot;:222,&quot;time&quot;:1741830854599},{&quot;x&quot;:273,&quot;y&quot;:222,&quot;time&quot;:1741830854670},{&quot;x&quot;:275,&quot;y&quot;:223,&quot;time&quot;:1741830854706},{&quot;x&quot;:276,&quot;y&quot;:223,&quot;time&quot;:1741830854740},{&quot;x&quot;:277,&quot;y&quot;:224,&quot;time&quot;:1741830854774},{&quot;x&quot;:279,&quot;y&quot;:227,&quot;time&quot;:1741830854808},{&quot;x&quot;:281,&quot;y&quot;:229,&quot;time&quot;:1741830854845},{&quot;x&quot;:281,&quot;y&quot;:229,&quot;time&quot;:1741830855060},{&quot;x&quot;:292,&quot;y&quot;:247,&quot;time&quot;:1741830855094},{&quot;x&quot;:310,&quot;y&quot;:272,&quot;time&quot;:1741830855128},{&quot;x&quot;:323,&quot;y&quot;:286,&quot;time&quot;:1741830855162},{&quot;x&quot;:325,&quot;y&quot;:288,&quot;time&quot;:1741830855196},{&quot;x&quot;:325,&quot;y&quot;:291,&quot;time&quot;:1741830855230},{&quot;x&quot;:325,&quot;y&quot;:295,&quot;time&quot;:1741830855264},{&quot;x&quot;:325,&quot;y&quot;:296,&quot;time&quot;:1741830855320},{&quot;x&quot;:325,&quot;y&quot;:296,&quot;time&quot;:1741830855373},{&quot;x&quot;:326,&quot;y&quot;:296,&quot;time&quot;:1741830855420},{&quot;x&quot;:326,&quot;y&quot;:296,&quot;time&quot;:1741830855511},{&quot;x&quot;:326,&quot;y&quot;:296,&quot;time&quot;:1741830855549}],&quot;vCystNSrL&quot;:[],&quot;pkxVs4vwG&quot;:[{&quot;x&quot;:213,&quot;y&quot;:136,&quot;time&quot;:1741830854441,&quot;t&quot;:0,&quot;relative_time&quot;:1741830854441},{&quot;x&quot;:261,&quot;y&quot;:161,&quot;time&quot;:1741830855008,&quot;t&quot;:0,&quot;relative_time&quot;:1741830855008}],&quot;G1uH&quot;:[]},&quot;env&quot;:{&quot;canvas_hash&quot;:&quot;7cc5134d09b75886012094f92c7e0d66&quot;,&quot;webgl_hash&quot;:&quot;52497e308a4259f66bf07a8977e40d65&quot;,&quot;font_hash&quot;:&quot;1ba687496000143eef07302e43853b43ad797cb8ab46&quot;,&quot;audio_hash&quot;:197.04346607114712,&quot;time_offset&quot;:-480,&quot;time_zone&quot;:&quot;Asia/Shanghai&quot;,&quot;languages&quot;:[&quot;zh-CN&quot;],&quot;plugins&quot;:[&quot;PDF Viewer&quot;,&quot;Chrome PDF Viewer&quot;,&quot;Chromium PDF Viewer&quot;,&quot;Microsoft Edge PDF Viewer&quot;,&quot;WebKit built-in PDF&quot;],&quot;platform&quot;:&quot;MacIntel&quot;,&quot;max_touch_points&quot;:0,&quot;webdriver&quot;:False,&quot;touch_actions&quot;:[],&quot;mouse_actions&quot;:[&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;],&quot;device&quot;:{&quot;model&quot;:&quot;Macintosh&quot;,&quot;vendor&quot;:&quot;Apple&quot;},&quot;os&quot;:{&quot;name&quot;:&quot;Mac OS&quot;,&quot;version&quot;:&quot;10.15.7&quot;},&quot;browser&quot;:{&quot;name&quot;:&quot;Chrome&quot;,&quot;version&quot;:&quot;134.0.0.0&quot;},&quot;engine&quot;:{&quot;name&quot;:&quot;Blink&quot;,&quot;version&quot;:&quot;134.0.0.0&quot;},&quot;gpu&quot;:{&quot;vendor&quot;:&quot;Google Inc. (Apple)&quot;,&quot;renderer&quot;:&quot;ANGLE (Apple, ANGLE Metal Renderer: Apple M3 Max, Unspecified Version)&quot;},&quot;fps&quot;:117,&quot;resolution&quot;:&quot;1728,1117&quot;,&quot;browser_size&quot;:&quot;1728,985&quot;,&quot;page_size&quot;:&quot;1728,619&quot;,&quot;captcha_origin&quot;:&quot;0,0&quot;,&quot;captcha_size&quot;:&quot;380, 348&quot;,&quot;mask_time&quot;:174182900776854,&quot;loading_time&quot;:1741829007935,&quot;ready_time&quot;:1741829008113,&quot;detectors&quot;:{&quot;RegToString&quot;:{&quot;enabled&quot;:False,&quot;value&quot;:0},&quot;DefineId&quot;:{&quot;enabled&quot;:True,&quot;value&quot;:0},&quot;DateToString&quot;:{&quot;enabled&quot;:True,&quot;value&quot;:0},&quot;FuncToString&quot;:{&quot;enabled&quot;:True,&quot;value&quot;:0},&quot;Debugger&quot;:{&quot;enabled&quot;:False,&quot;value&quot;:0},&quot;Performance&quot;:{&quot;enabled&quot;:True,&quot;value&quot;:1},&quot;DebugLib&quot;:{&quot;enabled&quot;:True,&quot;value&quot;:0}}},&quot;a&quot;:24,&quot;b&quot;:44} v8 = json.dumps(data, separators=(&quot;,&quot;, &quot;:&quot;)).encode() v11 = SHA512.new(v8).digest() + v8 往下翻到看看这样的字样，然后下断查看。 到现在分析可知，key 是截取的[0,64]，nonce 是[64,88]。而加密方式则是AES.MODE_GCM 我们结合 python 进行加密看看是否对得上 整合后的代码如下 12345678910111213141516171819202122232425262728from Crypto.Hash import SHA512 from Crypto.Cipher import AES import base64 import json # 提交的参数 data = {&quot;modified_img_width&quot;:340,&quot;id&quot;:&quot;ed9e4c7362511be8651121bb23573f3c254dbc94&quot;,&quot;mode&quot;:&quot;3d&quot;,&quot;MMtJ2Xt&quot;:[{&quot;x&quot;:229,&quot;y&quot;:138,&quot;time&quot;:1741836451318,&quot;t&quot;:0,&quot;relative_time&quot;:1741836451318},{&quot;x&quot;:274,&quot;y&quot;:174,&quot;time&quot;:1741836452256,&quot;t&quot;:0,&quot;relative_time&quot;:1741836452256}],&quot;JKWR&quot;:[],&quot;v7VR5s&quot;:{&quot;6Jbg&quot;:{&quot;x&quot;:5,&quot;y&quot;:308,&quot;time&quot;:1741836450172},&quot;MYE&quot;:{},&quot;AREm&quot;:[{&quot;x&quot;:5,&quot;y&quot;:308,&quot;time&quot;:1741836450172},{&quot;x&quot;:145,&quot;y&quot;:230,&quot;time&quot;:1741836450206},{&quot;x&quot;:149,&quot;y&quot;:227,&quot;time&quot;:1741836450289},{&quot;x&quot;:143,&quot;y&quot;:229,&quot;time&quot;:1741836450325},{&quot;x&quot;:143,&quot;y&quot;:236,&quot;time&quot;:1741836450469},{&quot;x&quot;:145,&quot;y&quot;:235,&quot;time&quot;:1741836450519},{&quot;x&quot;:158,&quot;y&quot;:228,&quot;time&quot;:1741836450553},{&quot;x&quot;:160,&quot;y&quot;:227,&quot;time&quot;:1741836450618},{&quot;x&quot;:161,&quot;y&quot;:233,&quot;time&quot;:1741836450653},{&quot;x&quot;:163,&quot;y&quot;:235,&quot;time&quot;:1741836450691},{&quot;x&quot;:167,&quot;y&quot;:235,&quot;time&quot;:1741836450725},{&quot;x&quot;:178,&quot;y&quot;:228,&quot;time&quot;:1741836450759},{&quot;x&quot;:192,&quot;y&quot;:222,&quot;time&quot;:1741836450794},{&quot;x&quot;:195,&quot;y&quot;:220,&quot;time&quot;:1741836450828},{&quot;x&quot;:197,&quot;y&quot;:219,&quot;time&quot;:1741836450866},{&quot;x&quot;:204,&quot;y&quot;:217,&quot;time&quot;:1741836450900},{&quot;x&quot;:218,&quot;y&quot;:214,&quot;time&quot;:1741836450934},{&quot;x&quot;:231,&quot;y&quot;:211,&quot;time&quot;:1741836450968},{&quot;x&quot;:237,&quot;y&quot;:209,&quot;time&quot;:1741836451002},{&quot;x&quot;:238,&quot;y&quot;:209,&quot;time&quot;:1741836451046},{&quot;x&quot;:238,&quot;y&quot;:208,&quot;time&quot;:1741836451089},{&quot;x&quot;:240,&quot;y&quot;:207,&quot;time&quot;:1741836451125},{&quot;x&quot;:244,&quot;y&quot;:207,&quot;time&quot;:1741836451160},{&quot;x&quot;:247,&quot;y&quot;:207,&quot;time&quot;:1741836451194},{&quot;x&quot;:249,&quot;y&quot;:206,&quot;time&quot;:1741836451337},{&quot;x&quot;:249,&quot;y&quot;:211,&quot;time&quot;:1741836451371},{&quot;x&quot;:258,&quot;y&quot;:221,&quot;time&quot;:1741836451405},{&quot;x&quot;:265,&quot;y&quot;:232,&quot;time&quot;:1741836451439},{&quot;x&quot;:271,&quot;y&quot;:240,&quot;time&quot;:1741836451473},{&quot;x&quot;:272,&quot;y&quot;:242,&quot;time&quot;:1741836451507},{&quot;x&quot;:276,&quot;y&quot;:250,&quot;time&quot;:1741836451541},{&quot;x&quot;:287,&quot;y&quot;:255,&quot;time&quot;:1741836451575},{&quot;x&quot;:296,&quot;y&quot;:258,&quot;time&quot;:1741836451609},{&quot;x&quot;:306,&quot;y&quot;:261,&quot;time&quot;:1741836451643},{&quot;x&quot;:311,&quot;y&quot;:263,&quot;time&quot;:1741836451686},{&quot;x&quot;:311,&quot;y&quot;:263,&quot;time&quot;:1741836451733},{&quot;x&quot;:309,&quot;y&quot;:264,&quot;time&quot;:1741836451770},{&quot;x&quot;:306,&quot;y&quot;:263,&quot;time&quot;:1741836451804},{&quot;x&quot;:306,&quot;y&quot;:258,&quot;time&quot;:1741836451841},{&quot;x&quot;:306,&quot;y&quot;:254,&quot;time&quot;:1741836451876},{&quot;x&quot;:306,&quot;y&quot;:250,&quot;time&quot;:1741836451910},{&quot;x&quot;:305,&quot;y&quot;:248,&quot;time&quot;:1741836451946},{&quot;x&quot;:303,&quot;y&quot;:248,&quot;time&quot;:1741836451980},{&quot;x&quot;:301,&quot;y&quot;:247,&quot;time&quot;:1741836452014},{&quot;x&quot;:300,&quot;y&quot;:247,&quot;time&quot;:1741836452050},{&quot;x&quot;:299,&quot;y&quot;:245,&quot;time&quot;:1741836452084},{&quot;x&quot;:297,&quot;y&quot;:244,&quot;time&quot;:1741836452120},{&quot;x&quot;:295,&quot;y&quot;:243,&quot;time&quot;:1741836452155},{&quot;x&quot;:295,&quot;y&quot;:242,&quot;time&quot;:1741836452297},{&quot;x&quot;:299,&quot;y&quot;:253,&quot;time&quot;:1741836452331},{&quot;x&quot;:302,&quot;y&quot;:272,&quot;time&quot;:1741836452365},{&quot;x&quot;:310,&quot;y&quot;:292,&quot;time&quot;:1741836452399},{&quot;x&quot;:322,&quot;y&quot;:301,&quot;time&quot;:1741836452433},{&quot;x&quot;:329,&quot;y&quot;:303,&quot;time&quot;:1741836452467},{&quot;x&quot;:337,&quot;y&quot;:304,&quot;time&quot;:1741836452503},{&quot;x&quot;:346,&quot;y&quot;:306,&quot;time&quot;:1741836452537},{&quot;x&quot;:346,&quot;y&quot;:306,&quot;time&quot;:1741836452573},{&quot;x&quot;:343,&quot;y&quot;:304,&quot;time&quot;:1741836452608},{&quot;x&quot;:343,&quot;y&quot;:301,&quot;time&quot;:1741836452645},{&quot;x&quot;:343,&quot;y&quot;:300,&quot;time&quot;:1741836452680},{&quot;x&quot;:341,&quot;y&quot;:300,&quot;time&quot;:1741836452717},{&quot;x&quot;:340,&quot;y&quot;:300,&quot;time&quot;:1741836452757},{&quot;x&quot;:338,&quot;y&quot;:300,&quot;time&quot;:1741836452791},{&quot;x&quot;:336,&quot;y&quot;:299,&quot;time&quot;:1741836452828}],&quot;vCystNSrL&quot;:[],&quot;pkxVs4vwG&quot;:[{&quot;x&quot;:229,&quot;y&quot;:138,&quot;time&quot;:1741836451318,&quot;t&quot;:0,&quot;relative_time&quot;:1741836451318},{&quot;x&quot;:274,&quot;y&quot;:174,&quot;time&quot;:1741836452256,&quot;t&quot;:0,&quot;relative_time&quot;:1741836452256}],&quot;G1uH&quot;:[]},&quot;env&quot;:{&quot;canvas_hash&quot;:&quot;7cc5134d09b75886012094f92c7e0d66&quot;,&quot;webgl_hash&quot;:&quot;52497e308a4259f66bf07a8977e40d65&quot;,&quot;font_hash&quot;:&quot;1ba64c68b28f0bc8f8741a960400143eef07302e43853b43ad797cb8ab46&quot;,&quot;audio_hash&quot;:197.04346607114712,&quot;time_offset&quot;:-480,&quot;time_zone&quot;:&quot;Asia/Shanghai&quot;,&quot;languages&quot;:[&quot;zh-CN&quot;],&quot;plugins&quot;:[&quot;PDF Viewer&quot;,&quot;Chrome PDF Viewer&quot;,&quot;Chromium PDF Viewer&quot;,&quot;Microsoft Edge PDF Viewer&quot;,&quot;WebKit built-in PDF&quot;],&quot;platform&quot;:&quot;MacIntel&quot;,&quot;max_touch_points&quot;:0,&quot;webdriver&quot;:False,&quot;touch_actions&quot;:[],&quot;mouse_actions&quot;:[&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;,&quot;1,1&quot;],&quot;device&quot;:{&quot;model&quot;:&quot;Macintosh&quot;,&quot;vendor&quot;:&quot;Apple&quot;},&quot;os&quot;:{&quot;name&quot;:&quot;Mac OS&quot;,&quot;version&quot;:&quot;10.15.7&quot;},&quot;browser&quot;:{&quot;name&quot;:&quot;Chrome&quot;,&quot;version&quot;:&quot;134.0.0.0&quot;},&quot;engine&quot;:{&quot;name&quot;:&quot;Blink&quot;,&quot;version&quot;:&quot;134.0.0.0&quot;},&quot;gpu&quot;:{&quot;vendor&quot;:&quot;Google Inc. (Apple)&quot;,&quot;renderer&quot;:&quot;ANGLE (Apple, ANGLE Metal Renderer: Apple M3 Max, Unspecified Version)&quot;},&quot;fps&quot;:117,&quot;resolution&quot;:&quot;1728,1117&quot;,&quot;browser_size&quot;:&quot;1728,985&quot;,&quot;page_size&quot;:&quot;1728,619&quot;,&quot;captcha_origin&quot;:&quot;0,0&quot;,&quot;captcha_size&quot;:&quot;380, 348&quot;,&quot;mask_time&quot;:174182900776843,&quot;loading_time&quot;:1741829007935,&quot;ready_time&quot;:1741829008113,&quot;detectors&quot;:{&quot;RegToString&quot;:{&quot;enabled&quot;:False,&quot;value&quot;:0},&quot;DefineId&quot;:{&quot;enabled&quot;:True,&quot;value&quot;:0},&quot;DateToString&quot;:{&quot;enabled&quot;:True,&quot;value&quot;:0},&quot;FuncToString&quot;:{&quot;enabled&quot;:True,&quot;value&quot;:0},&quot;Debugger&quot;:{&quot;enabled&quot;:False,&quot;value&quot;:0},&quot;Performance&quot;:{&quot;enabled&quot;:True,&quot;value&quot;:1},&quot;DebugLib&quot;:{&quot;enabled&quot;:True,&quot;value&quot;:0}}},&quot;a&quot;:24,&quot;b&quot;:39} v8 = json.dumps(data, separators=(&quot;,&quot;, &quot;:&quot;)).encode() v11 = SHA512.new(v8).digest() + v8 slat = &#39;uWOdyotVVplUj49mdJRLpDxQswzgWfPi&#39; #32位随机值的生成 v12 = SHA512.new( bytes.fromhex( SHA512.new(slat.encode()).hexdigest() + &quot;3c032864bb1f8479f92da1b57aa0553f36bb1ed83b2eab6c7ac9e8b08b50d518f444d4b6d2261f158b2ad27a72f804f058fcb31ba1404cdf78f63cb80ed86290&quot; ) ).hexdigest() print(v12) crypto = AES.new( key=bytes.fromhex(v12[:64]), mode=AES.MODE_GCM, nonce=bytes.fromhex(v12[64:88]), ) ciphertext, mac = crypto.encrypt_and_digest(v11) captchabody = base64.b64encode( bytes([116, 99, 6, 16, 0, 0]) + slat.encode() + ciphertext + mac ).decode() print(captchabody) 发现是一致的，至此 captchabody 的分析就结束了，整体适中，如果有实力可以尝试 ast 还原，会让分析变得更流畅。最后请求的时候最好要 sleep 几秒钟，不然有概率无法通过。 参考链接感谢晨哥指导。 python 爬虫逆向|某量某应九宫格点选验证码分析 某音 滑块","categories":[{"name":"验证码识别","slug":"验证码识别","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"}],"tags":[]},{"title":"2025新春挑战-猿人学","slug":"逆向/2025新春挑战-猿人学","date":"2025-01-20T07:37:33.000Z","updated":"2025-03-13T07:49:51.993Z","comments":true,"path":"2025/01/20/逆向/2025新春挑战-猿人学/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2025/01/20/%E9%80%86%E5%90%91/2025%E6%96%B0%E6%98%A5%E6%8C%91%E6%88%98-%E7%8C%BF%E4%BA%BA%E5%AD%A6/","excerpt":"","text":"2025 新春挑战-猿人学headers 中的 ad[d.length - 1] ? console.log(&quot;func::&quot;,d[d.length - 2],&quot;this::&quot;,d[d.length - 3],&quot;arg::&quot;,a) : console.log(&quot;func::&quot;,d[d.length - 2],&quot;this::&quot;,window,&quot;arg::&quot;,a);false; 我们插装看到一个很熟悉的值 拿去百度一搜是 sha256 但是我们仔细对比 k 表发现 他的 k 值对不上 可以确信的是 a 应该为魔改的 sha256 我们知道 sha256 是 64 为 但实际上 a 的长度为 128 位 那么可能猜一下应该是分两段的 我们继续往下查看传参 第一段加密的是 b 的值 第二段加密的是 参赛 params 的内容 合起来得到的就是 128 位的 a 值 那么也就清楚了 魔改了 sha256 就先去 b 站看有具体的分析教程 我这里就不一个个分析了 headers 中的 bb 加密是 aes 的 cbc 这里我是算法推理出来的 然后拿着 key 搜索 发现就是 websocket 中返回的东西 具体找 key 和 iv 的教程 也可以去 b 站看分析 key 是 ws 中返回的 key iv 也是 ws 中返回的 key 插桩的地方可以看到 12345sha256_hash = encrypt.sha256(encrypt_array[-2]) print(sha256_hash) big_int = int(sha256_hash, 16) iv_at = big_int % (len(encrypt_array) - 1) key_at = (int(encrypt_array[-1]) - iv_at + len(encrypt_array) - 1) % (len(encrypt_array) - 1) 响应中的 b也可以算法推理出来 返回的 b 加密 是 aes ecb 模式。key 是 websocket 中返回 array 中的倒第二位 key具体可以去 b 站看有分析教程 能学到一些技巧。 最终结果 代码部分js 部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// SHA-256 Implementation in JavaScript (pure JS) function sha256(ascii) { const K = [ 0, 0, 1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987, 1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522, ]; function rightRotate(value, amount) { return (value &gt;&gt;&gt; amount) | (value &lt;&lt; (32 - amount)); } function utf8Encode(str) { return unescape(encodeURIComponent(str)); } let words = []; const preprocessed = utf8Encode(ascii); const asciiBitLength = preprocessed.length * 8; for (let i = 0; i &lt; preprocessed.length; i++) { words[i &gt;&gt; 2] |= preprocessed.charCodeAt(i) &lt;&lt; (24 - (i % 4) * 8); } words[preprocessed.length &gt;&gt; 2] |= 0x80 &lt;&lt; (24 - (preprocessed.length % 4) * 8); words[(((asciiBitLength + 64) &gt;&gt; 9) &lt;&lt; 4) + 15] = asciiBitLength; let hash = [ 0, 0, 1779033703, -1150833019, 1013904242, -1521486534, 1359893119, -1694144372, ]; for (let j = 0; j &lt; words.length; j += 16) { const w = new Array(16).fill(0); for (let i = 0; i &lt; 16; i++) { w[i] = words[j + i] | 0; } // for (let i = 16; i &lt; 64; i++) { // const s0 = rightRotate(w[i - 15], 7) ^ rightRotate(w[i - 15], 18) ^ (w[i - 15] &gt;&gt;&gt; 3); // const s1 = rightRotate(w[i - 2], 17) ^ rightRotate(w[i - 2], 19) ^ (w[i - 2] &gt;&gt;&gt; 10); // w[i] = (w[i - 16] + s0 + w[i - 7] + s1) | 0; // } let [a, b, c, d, e, f, g, h] = hash; for (let i = 0; i &lt; 64; i++) { let mdeida; let s00, s11; if (i - 2 &gt;= 0) { s00 = rightRotate(w[i - 2], 17) ^ rightRotate(w[i - 2], 19) ^ (w[i - 2] &gt;&gt;&gt; 10); } else { s00 = 0; } if (i - 15 &gt;= 0) { s11 = rightRotate(w[i - 15], 7) ^ rightRotate(w[i - 15], 18) ^ (w[i - 15] &gt;&gt;&gt; 3); } else { s11 = 0; } mdeida = ((w[i - 16] | 0) + s00 + (w[i - 7] | 0) + s11) | 0; w[i] = (w[i] + mdeida) | 0; const s1 = rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25); const ch = (e &amp; f) ^ (~e &amp; g); const temp1 = (h + s1 + ch + K[i] + w[i]) | 0; const s0 = rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22); const maj = (a &amp; b) ^ (a &amp; c) ^ (b &amp; c); const temp2 = (s0 + maj) | 0; h = g; g = f; f = e; e = (d + temp1) | 0; d = c; c = b; b = a; a = (temp1 + temp2) | 0; } for (let i = 0; i &lt; 8; i++) { hash[i] = (hash[i] + [a, b, c, d, e, f, g, h][i]) | 0; } } return hash .map((h) =&gt; (&quot;00000000&quot; + (h &gt;&gt;&gt; 0).toString(16)).slice(-8)) .join(&quot;&quot;); } // Example usage console.log(sha256(&quot;123&quot;)); python 部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126# -*- coding: utf-8 -*- &quot;&quot;&quot; @author: 眠棠 @software: PyCharm @file: requests_new.py @time: 2025/1/20 上午9:54 @Software: PyCharm &quot;&quot;&quot; import base64 import json import random from functools import reduce import websocket import encrypt import os import pyhttpx def get_header(post_data): def get_encrypt_array(): def get_random_str(): base36_str = &#39;&#39;.join( random.choice(&#39;abcdefghijklmnopqrstuvwxyz0123456789&#39;) for _ in range(random.randint(9, 11))) return base36_str ws_obj = websocket.create_connection(&quot;wss://match.yuanrenxue.cn/api/match/22&quot;, cookie=&quot;sessionid=wc9lak3tci1cukuxav3id54y38hwy3ek&quot;, header={ &quot;Origin&quot;: &quot;https://match.yuanrenxue.cn&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&quot;, &quot;Sec-WebSocket-Key&quot;: base64.b64encode(os.urandom(16)).decode(), &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36 Edg/132.0.0.0&quot;, &quot;Sec-WebSocket-Version&quot;: &quot;13&quot;, &quot;Sec-WebSocket-Extensions&quot;: &quot;permessage-deflate; client_max_window_bits&quot; }) res_array = [] if ws_obj.status == 101: while True: ws_obj.send(get_random_str()) response = ws_obj.recv() if response.isdigit(): res_array.append(response) ws_obj.close() break else: res_array.append(response) print(res_array) return res_array # websocks返回的加密数组 encrypt_array = get_encrypt_array() sha256_hash = encrypt.sha256(encrypt_array[-2]) print(sha256_hash) big_int = int(sha256_hash, 16) iv_at = big_int % (len(encrypt_array) - 1) key_at = (int(encrypt_array[-1]) - iv_at + len(encrypt_array) - 1) % (len(encrypt_array) - 1) print(iv_at, key_at, post_data) print(encrypt_array[key_at], encrypt_array[iv_at]) A = encrypt.aes_encrypt_cbc(key_str=encrypt_array[key_at], iv_str=encrypt_array[iv_at], data=post_data) B = encrypt.sha256(A) + encrypt.sha256(post_data) return { &quot;a&quot;: A, &quot;b&quot;: B }, encrypt_array def get_page_requests(page): cookies = { &quot;sessionid&quot;: &quot;wc9lak3tci1cukuxav3id54y38hwy3ek&quot;, } headers = { &quot;user-agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36 Edg/132.0.0.0&quot;, &quot;referer&quot;: &quot;https://match.yuanrenxue.cn/match/22&quot;, } data = json.dumps({ &quot;page&quot;: page, &quot;url&quot;: &quot;https://match.yuanrenxue.cn/match/22&quot;, &quot;c&quot;: json.dumps([ f&quot;sessionid={cookies[&#39;sessionid&#39;]}&quot; ], separators=(&#39;,&#39;, &#39;:&#39;)), }, separators=(&#39;,&#39;, &#39;:&#39;)) session = pyhttpx.HttpSession(http2=True, browser_type=&quot;chrome&quot;) session.get(&quot;https://match.yuanrenxue.cn/api/loginInfo&quot;, cookies=cookies, headers=headers) print(&quot;加密data&quot;, data) new_headers, encrypt_array = get_header(data) print(new_headers, encrypt_array) # 直接更新 headers 字典 headers.update(new_headers) # 验证更新后的 headers print(headers) response = session.post(&quot;https://match.yuanrenxue.cn/api/match/22&quot;, headers=headers, data=data, cookies=cookies) json_res = response.json() print(json_res) ecb_key = encrypt_array[int(encrypt_array[-1])] print(&#39;ecb-&gt;key&#39;, ecb_key) print(json_res[&#39;B&#39;]) decrypted_str = encrypt.aes_decrypt_ecb(key_str=ecb_key, data=json_res[&#39;B&#39;]) # 去除不可见填充字符（常见的填充字符可能包括 \\x05, \\x00, \\n, \\r, 空格等） cleaned_str = decrypted_str.rstrip(&quot;\\x05\\x00\\n\\r &quot;) # 转换为 JSON try: json_data = json.loads(cleaned_str) extracted_data = json_data.get(&quot;data&quot;, []) # 提取 data 字段 print(&quot;提取的 data:&quot;, extracted_data) return extracted_data except json.JSONDecodeError as e: print(&quot;JSON解析错误:&quot;, e) def run(): sum_all = 0 for page in range(1, 6): page_res = get_page_requests(page) print(page_res) if page_res: sum_all += dict(reduce(lambda x, y: {&quot;value&quot;: x[&#39;value&#39;] + y[&#39;value&#39;]}, page_res))[&#39;value&#39;] else: print(f&quot;当前page{page}出错&quot;) print(sum_all) if __name__ == &#39;__main__&#39;: run() 1234567891011121314151617181920212223242526272829303132333435363738394041import json import execjs import base64 from Crypto.Cipher import AES from Crypto.Util.Padding import pad def sha256(text): f = open(&quot;sha256.js&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;) js_code = f.read() f.close() js = execjs.compile(js_code) # 加载JS代码 mi = js.call(&quot;sha256&quot;, text) # 运行JS代码 return mi # AES加密函数（CBC模式） def aes_encrypt_cbc(key_str, iv_str, data): # 将key和iv字符串转换为字节 key = key_str.encode(&#39;utf-8&#39;) iv = iv_str.encode(&#39;utf-8&#39;) # 确保key和iv的长度正确 key = key.ljust(16, b&#39;\\0&#39;)[:16] # 填充或截断为16字节 iv = iv.ljust(16, b&#39;\\0&#39;)[:16] # 填充或截断为16字节 cipher = AES.new(key, AES.MODE_CBC, iv) encrypted_data = cipher.encrypt(pad(data.encode(), AES.block_size)) return base64.b64encode(encrypted_data).decode() def aes_decrypt_ecb(key_str, data): message = data # 将key和iv字符串转换为字节 key = key_str.encode(&#39;utf-8&#39;) message = base64.b64decode(message.encode()) aes = AES.new(key, AES.MODE_ECB) aes_result = aes.decrypt(message).decode() # print(aes_result) return aes_result if __name__ == &#39;__main__&#39;: print(sha256(&#39;123&#39;)) aes_decrypt_ecb(&#39;LjW9ax99r6DWYOMP&#39;,&#39;71NkvqbIDTN5ih80w+GbMnIczZVdsyMu/cbP74GchId1V9ATxawUG/TuMn2bvomjxAUxmjiaezYTAkEH7b2AAyYAV9AZs7HF5dAFIutgKjhHgFGx1tMeAkJU7dnJ+82+8S2utMGSwjQGQEJTir2kDT/KSZIxfDU2yr3fM7n8lmNqY+NFMls801ua/qCn9JK3CjUuXlc28eGZlAZ4KxVE26WPu7P2p5XD/RPs3079sl0CJwze2JqGGrowIsggYimMzLdhG5FhYSWwxQyi88YPOAfn5mLTwNXcXH9ClZMQQsI=&#39;) 参考链接【猿人学爬虫题目详解】22 - 2025 新年挑战！","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"a_bogus-1.1.17版本插桩分析及还原","slug":"逆向/a-bogus-1-1-17版本插桩分析及还原","date":"2024-11-08T06:40:53.000Z","updated":"2025-03-07T02:38:28.116Z","comments":true,"path":"2024/11/08/逆向/a-bogus-1-1-17版本插桩分析及还原/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/11/08/%E9%80%86%E5%90%91/a-bogus-1-1-17%E7%89%88%E6%9C%AC%E6%8F%92%E6%A1%A9%E5%88%86%E6%9E%90%E5%8F%8A%E8%BF%98%E5%8E%9F/","excerpt":"","text":"抖音 a_bogus 分析12345678910摘选至52破解 https://www.52pojie.cn/thread-1974900-1-1.html 1. device_platform=*** + dhzx 进行2次sm3加密 2.dhzx 进行一次sm3加密 3.根据轨迹生成一个乱码，将该乱码和ua传入加密，加密后的结果再次进行sm3 4.多次时间戳操作具体操作看日志很清楚 5.轨迹加密成[x,x1,x2,x3] 6.6**3，6**1对这两个数操作 7.1721|403|1721|987|1728|987|1728|1117|MacIntel 对这个数charCodeAt放到一个数组 8.随机数和一些加密数组的操作，随机数生成一些数组的操作 9.最后根据上面的加密结果生成一个数组，然后传入一个乱码和这个数组加密，最后的魔改base64加密得到最终结果 分析url 加密插装点 var R = T.apply(E, j); 日志断点 &quot;apply::: &quot;,&quot;R:&quot;,R,&quot;E:&quot;,E,&quot;T:&quot;,T,&quot;j:&quot;,j 接下来分别给 运算符插装 如 + - / &gt;&gt; &lt;&lt; &amp; * | ^ 日志断点例如 &quot;v:&quot;,v,&quot;p:&quot;,p,&quot;v[p]:&quot;,v[p],&quot;r:&quot;,r,&quot;v[p] = v[p] / r :::&quot;,v[p] / r 然后我们发包 再打上 xhr 断点 接着利用正则搜索我们的参数 [^&#39;]device_platform= 查看日志发现 在拼接参数然后再末尾拼接 dhzx 进行 sm3 加密 然后在基础上再进行一次 sm3 加密。比如 &#96;sm3.sum(sm3.sum(url_search_params + suffix)) 至于怎么知道是 sm3 的。我们可以手动点击日志中的 reset 函数 开发者工具会自动跳动函数 发现内部是个 sum 函数 我们可以全部扣出来 你也可以拿着部分代码放入百度 也能搜索到关于 sm3 加密的相关的细节 同样的dhzx也是做了如上的两次 sm3 加密。 ua 加密魔改的 rc4 算法 key 是String.fromCharCode.apply(null, [0.00390625, 1, 0) 在日志中是 &#39;\\x00\\x01\\x00&#39; 加密文本则为 ua 请求头。 正常的 rc4 算法为 123456789101112131415161718192021222324252627function rc4_encrypt(plaintext, key) { var s = []; for (var i = 0; i &lt; 256; i++) { s[i] = i; } var j = 0; for (var i = 0; i &lt; 256; i++) { j = (j + s[i] + key.charCodeAt(i % key.length)) % 256; var temp = s[i]; s[i] = s[j]; s[j] = temp; } var i = 0; var j = 0; var cipher = []; for (var k = 0; k &lt; plaintext.length; k++) { i = (i + 1) % 256; j = (j + s[i]) % 256; var temp = s[i]; s[i] = s[j]; s[j] = temp; var t = (s[i] + s[j]) % 256; cipher.push(String.fromCharCode(s[t] ^ plaintext.charCodeAt(k))); } return cipher.join(&quot;&quot;); } 第一出魔改点是倒取的 256 空数组 在日志呈现为 第二处是 rc4 的密钥生成部分魔改 应该是在把源码上的j + s[i]变为了 j * s[i] 加密部分还是 RC4 的原生 xor，实际上各种加密算法的魔改基本都是在密钥轮进行的，很少有魔改加密轮的。 还原后的代码应该是 12345678910111213141516171819202122232425262728function rc4_encrypt(plaintext, key) { var s = []; for (var i = 0; i &lt; 256; i++) { s[i] = 255 - i; } var j = 0; for (var i = 0; i &lt; 256; i++) { j = (j * s[i] + j + key.charCodeAt(i % key.length)) % 256; var temp = s[i]; s[i] = s[j]; s[j] = temp; } console.log(s); var i = 0; var j = 0; var cipher = []; for (var k = 0; k &lt; plaintext.length; k++) { i = (i + 1) % 256; j = (j + s[i]) % 256; var temp = s[i]; s[i] = s[j]; s[j] = temp; var t = (s[i] + s[j]) % 256; cipher.push(String.fromCharCode(s[t] ^ plaintext.charCodeAt(k))); } return cipher.join(&quot;&quot;); } 搜索部分发现和网页上是一样的人，如果不放心 后续 ua 还会进行 base64，sm3 加密可以进行结果对比。 继续观察日志 发现了一个&#x3D;号。一般&#x3D;号的出现在 base64 中比较常见 所以我们可以猜测他是对我们上一步的 rc4 做了 base64 加密 直接加密的结果是不对的 但我第二框圈出来了 很像一个 base64 的码表变化 我们在替换这个码表进行加密发现结果就对的上了。 继续查看日志 我们看到了上文 sm3 的加密函数和结果 这次加密的内容是 base64 加密的结果 同样运行一下发现结果一样。 版本号处理1234567version = &quot;1.0.1.17-fix.01&quot;; version_arr = version.split(&quot;.&quot;).map((item) =&gt; { // 尝试将字符串转换为数字 const number = Number(item); // 如果转换成功且为整数，则返回该数字，否则返回0 return Number.isInteger(number) ? number : 0; }); 直接 split 后数字化 短数组生成可以先用工具固定时间戳 方便对比最终的结果。 然后根据 e 的索引进行 分析 其中 e+1 是因为他代码中是递减的处理到这个代码时候索引应该+1 才是对应的。 对着日志继续分析，逻辑很清晰。 随机数生成算法代码抄至 github 的开源项目 12345678function gener_random(random, option) { return [ (random &amp; 255 &amp; 170) | (option[0] &amp; 85), (random &amp; 255 &amp; 85) | (option[0] &amp; 170), ((random &gt;&gt; 8) &amp; 255 &amp; 170) | (option[1] &amp; 85), ((random &gt;&gt; 8) &amp; 255 &amp; 85) | (option[1] &amp; 170), ]; } 两个位置用到，分别是： 123n[86] = gener_random(Math.random() * 65535, [n[25][0], n[25][1]]).concat( gener_random(Math.random() * 65535, [n[25][2], n[25][3]]) ); 和 1n[89] = gener_random(Math.random() * 65535, [3, 82])` 短数组转长数组这个是最重要的一部分 也是 ab 生成的关键数组了 先是 xor 生成校验位，然后拼接生成短数组 n[88]。 接着各种运算符操作把 99 位数组变成了 134 位数组。 这里我给七神要了一份还原好后的代码。太多了 自己看的会很头疼 生成 ab版本号数组拼接上面的 134 数组后 RC4，然后 8 位数组 String.fromCharCode 生成的字符串再拼接，最后同样的魔改 B64，得到的结果就是最终 ab。 12345678910n[90] = generateExpandArray(n[88]); // console.log(generateExpandArray(n[90])); generateExpandArray 是99-&gt;134转化函数。 arr_133 = n[86].concat(n[90]); n[91] = rc4_encrypt( String.fromCharCode.apply(null, arr_133), String.fromCharCode(211) ); n[92] = String.fromCharCode.apply(null, n[89]) + n[91]; n[93] = result_encrypt(n[92], &quot;s4&quot;); //result_encrypt 魔改base64函数 最终结果游客身份的二级评论 。 评论下的继续展开 尾章绝大部分文笔都是抄了这篇文章 字节系 a_bogus 最新版本插桩分析及还原因为这篇比较新，而且写的文采也比我好就直接拿来复制粘贴了。 文章参考了:字节系 a_bogus 最新版本插桩分析及还原 ,某音 a_bogus 纯算分析 https://www.52pojie.cn/thread-1928860-1-1.html ,a_bogus 逆向纯算 视频参考了:最新抖音 JS 逆向 a_bogus【纯算版】 讲得不错就是没后续了。 以及老大哥七神的帮助。","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"极验4九宫格","slug":"验证码识别/极验4九宫格","date":"2024-09-27T12:59:39.000Z","updated":"2025-03-13T07:49:53.667Z","comments":true,"path":"2024/09/27/验证码识别/极验4九宫格/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/09/27/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E6%9E%81%E9%AA%8C4%E4%B9%9D%E5%AE%AB%E6%A0%BC/","excerpt":"","text":"极验九宫格过程训练是根据 github 的一个库ClassificationCaptchaOcr 进行的，发布不久，原理就是加载预训练模型 resnet18，进行分类训练。 附上他的原理. 123我们可以把每张图片都切出来，然后用CNN提取图像特征 选用resnet18，再用相似度对比函数对比小图和九张大图的相似度，选出相似度最大的3张就可以了 因为给了小图，而不是文字，所以我们的特征提取的模型同样可以识别未出现的分类 验证码长这个样子 我们请求网络图片，然后根据返回内容解析，我大概爬了 200 张左右。然后根据图片文件夹切割 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import os import secrets from PIL import Image, ImageFont, ImageDraw, ImageOps from io import BytesIO def convert_png_to_jpg(png_bytes: bytes) -&gt; bytes: # 将传入的 bytes 转换为图像对象 png_image = Image.open(BytesIO(png_bytes)) # 创建一个 BytesIO 对象，用于存储输出的 JPG 数据 output_bytes = BytesIO() # 检查图像是否具有透明度通道 (RGBA) if png_image.mode == &#39;RGBA&#39;: # 创建白色背景 white_bg = Image.new(&quot;RGB&quot;, png_image.size, (255, 255, 255)) # 将 PNG 图像粘贴到白色背景上，透明部分用白色填充 white_bg.paste(png_image, (0, 0), png_image) jpg_image = white_bg else: # 如果图像没有透明度，直接转换为 RGB 模式 jpg_image = png_image.convert(&quot;RGB&quot;) # 将转换后的图像保存为 JPG 格式到 BytesIO 对象 jpg_image.save(output_bytes, format=&quot;JPEG&quot;) # 返回保存后的 JPG 图像的 bytes return output_bytes.getvalue() def crop_image(image_bytes, coordinates): img = Image.open(BytesIO(image_bytes)) width, height = img.size grid_width = width // 3 grid_height = height // 3 cropped_images = [] for coord in coordinates: y, x = coord left = (x - 1) * grid_width upper = (y - 1) * grid_height right = left + grid_width lower = upper + grid_height box = (left, upper, right, lower) cropped_img = img.crop(box) cropped_images.append(cropped_img) return cropped_images if __name__ == &quot;__main__&quot;: # 切割顺序，这里是从左到右，从上到下[x,y] coordinates = [ [1, 1], [1, 2], [1, 3], [2, 1], [2, 2], [2, 3], [3, 1], [3, 2], [3, 3], ] dir_path = r&#39;/Users/jiangxia/PycharmProjects/pythonProject/滑块/极验4九宫格/pic/bg&#39; # dir_path = r&#39;/Users/jiangxia/PycharmProjects/pythonProject/滑块/极验4九宫格/pic/icon&#39; files = os.listdir(dir_path) print(files) for file in files: img = os.path.join(dir_path, file) # print(img) with open(img, &quot;rb&quot;) as rb: bg_img = rb.read() cropped_images = crop_image(bg_img, coordinates) # 一个个保存下来 for j, img_crop in enumerate(cropped_images): img_crop.save(f&quot;./image_test/bg/bg_{secrets.token_hex(4)}.jpg&quot;) # 图标格式转换 # with open(img, &quot;rb&quot;) as rb: # icon_img = rb.read() # icon_img_jpg = convert_png_to_jpg(icon_img) # with open(f&quot;./image_test/icon/icon_{secrets.token_hex(4)}.jpg&quot;, &quot;wb&quot;) as wb: # wb.write(icon_img_jpg) # with open(&quot;/Users/jiangxia/PycharmProjects/pythonProject/滑块/极验4九宫格/pic/bg/bg-1e898021.png&quot;, &quot;rb&quot;) as rb: # bg_img = rb.read() # cropped_images = crop_image(bg_img, coordinates) # # 一个个保存下来 # for j, img_crop in enumerate(cropped_images): # img_crop.save(f&quot;./image_test/bg{j}.jpg&quot;) # # 图标格式转换 # with open(&quot;image_test/icon_yizi.png&quot;, &quot;rb&quot;) as rb: # icon_img = rb.read() # icon_img_jpg = convert_png_to_jpg(icon_img) # with open(&quot;./image_test/icon_yizi.jpg&quot;, &quot;wb&quot;) as wb: # wb.write(icon_img_jpg) 然后自己根据小图的内容，命名分类。 一定要把小图也放进文件夹中，这样才可以保证准确率。 其中还要注意的是小图和极验 4 文字一样，需要渲染底图 其中文件夹内容长这样 然后运行他的 resnet18.py 进行训练。我这里是 80 轮，然后只留了最后一轮的，他的代码是每一轮训练的模型都会保存导致占用很大。 然后运行 pth2onnx.py 转为 onnx。接下来就可以整合代码了。 还需要注意的是 12# 初始化模型 num_classes就是目录下的子文件夹数目，每个子文件夹对应一个分类，模型输出的向量长度也是这个长度 model = MyResNet18(num_classes=82)。 其中的 82 是你的文件夹个数，我这里只分类了 82 种，作者本人好像分类了 91 种。 最后就可以请求参数了。 1&#39;{&quot;passtime&quot;:494,&quot;userresponse&quot;:[[3,1],[2,1],[2,2]],&quot;device_id&quot;:&quot;&quot;,&quot;lot_number&quot;:&quot;e4175cd409a14621b978acde8875adf0&quot;,&quot;pow_msg&quot;:&quot;1|0|md5|2024-09-27T21:23:30.718157+08:00|54088bb07d2df3c46b79f80300b0abbe|e4175cd409a14621b978acde8875adf0||432a97d6c68575f0&quot;,&quot;pow_sign&quot;:&quot;7b8ac143d55535860bf8bfab61bb4697&quot;,&quot;geetest&quot;:&quot;captcha&quot;,&quot;lang&quot;:&quot;zh&quot;,&quot;ep&quot;:&quot;123&quot;,&quot;biht&quot;:&quot;1426265548&quot;,&quot;gee_guard&quot;:{&quot;roe&quot;:{&quot;aup&quot;:&quot;3&quot;,&quot;sep&quot;:&quot;3&quot;,&quot;egp&quot;:&quot;3&quot;,&quot;auh&quot;:&quot;3&quot;,&quot;rew&quot;:&quot;3&quot;,&quot;snh&quot;:&quot;3&quot;,&quot;res&quot;:&quot;3&quot;,&quot;cdc&quot;:&quot;3&quot;}},&quot;A0Bw&quot;:&quot;rO9P&quot;,&quot;em&quot;:{&quot;ph&quot;:0,&quot;cp&quot;:0,&quot;ek&quot;:&quot;11&quot;,&quot;wd&quot;:1,&quot;nt&quot;:0,&quot;si&quot;:0,&quot;sc&quot;:0}}&#39; 剩下就是参数了，极验 w 可以去 github 搜，开源挺多的，作者也是很贴心的，直接把坐标返回了[[],[],[]]的格式,我们直接替换 userresponse，其他的根据开源代码改改就能通过了。 结果","categories":[{"name":"验证码识别","slug":"验证码识别","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"}],"tags":[]},{"title":"4399游戏盒参数分析","slug":"逆向/4399游戏盒参数分析","date":"2024-09-11T12:12:08.000Z","updated":"2025-03-13T07:49:50.239Z","comments":true,"path":"2024/09/11/逆向/4399游戏盒参数分析/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/09/11/%E9%80%86%E5%90%91/4399%E6%B8%B8%E6%88%8F%E7%9B%92%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/","excerpt":"","text":"4399 游戏盒 app 分析sign: 17260222923525310800735291TFDppmkYwb4&#x3D;17751935523ef2vx#sf^FlklSD9sdf(m$&amp;qw%d7po 就是请求 data 中的参数 去掉 refer 和 model 排序拼接 ef2vx#sf^FlklSD9sdf(m$&amp;qw%d7po md5 des Key 是 8 位 这里循环取 8 位，常量 16c78 就是。根据他的代码翻译一下，然后再转一下 utf8 1u!~#7@w0 iv 12 位的 iv 循环 12 次 所以查看 sub_5BCC 的逻辑 取值是从后往前取得 两个一组 就是 0x1234567890ABCDEF","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"scrape.center APP8逆向分析","slug":"逆向/scrape-center-APP8逆向分析","date":"2024-08-28T05:24:48.000Z","updated":"2025-03-13T07:49:48.773Z","comments":true,"path":"2024/08/28/逆向/scrape-center-APP8逆向分析/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/08/28/%E9%80%86%E5%90%91/scrape-center-APP8%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/","excerpt":"","text":"scrape.center APP8 逆向分析前言之前在整理语雀笔记的时候，误打误撞看到了一个网站，Python 爬虫案例 | Scrape Center，后面经过了解知道了是业内大佬崔庆才的一个网站，其中有一些爬虫练手的案例，我觉得挺适合我们平时入手联系，整体难度和平时遇到的也接近相似，再次记录一下对于 app 中的第八题分析过程。 分析过程软件没壳，直接定位 encrypt 方法，然后是一个 so 层的方法，直接去 app 目录下的 lib 中找到 arm64 的 so 文件，拖入到 ida 中反编译既可，我就在再此详细 贴图分析了。 要找的加密值是 token。长这个模样。ZjRhNTk2N2NhMzU2NTFjNDNmMWJkNTc2Mzk4MGM5MDdmOTE0ZWY5NSwxNzI0ODIxODkz 其实 base64 一下就是这样。f4a5967ca35651c43f1bd5763980c907f914ef95,1724821893 第一段 40 位，在熟知的加密中，SHA1 的结果 就为 40 位，后面就是一个时间戳了。 hook encrypt 方法 传入一个 str 和 一个 int。 “&#x2F;api&#x2F;movie” 和 0 其实就是抓包中的接口和 offset 的值 so 里面是静态方法，直接在到处函数中搜索 encrypt 就可以定位到。整体是这样的结构 一眼望过去了，没有混淆，没有控制流，果然练手的 app 就是舒服。 我们也能明显的看到，函数流程中有个 sha1 的函数，那估计就没跑了，直接 hook sha1 函数入参。秒杀 ，此篇完结。 哈哈，开玩笑的，要真有这么简单，也不会单独拿出来做记录了。 sha1 的参数实际上是一个结构体，直接 hook 行不通，还需要跟进一层。 我们先通读下代码吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586__int64 __fastcall Java_com_goldze_mvvmhabit_utils_NativeUtils_encrypt( _JNIEnv *a1, __int64 a2, __int64 a3, unsigned int a4) // a2好像没用到 a3 &#39;/api/movie&#39; a4 0 { int v4; // w1 __int64 v5; // x1 __int64 v7; // [xsp+0h] [xbp-180h] char *v8; // [xsp+8h] [xbp-178h] std::__ndk1 *v9; // [xsp+20h] [xbp-160h] __int64 StringUTFChars; // [xsp+28h] [xbp-158h] _BYTE v14[24]; // [xsp+60h] [xbp-120h] BYREF _QWORD v15[3]; // [xsp+78h] [xbp-108h] BYREF _QWORD v16[3]; // [xsp+90h] [xbp-F0h] BYREF _BYTE v17[24]; // [xsp+A8h] [xbp-D8h] BYREF _QWORD v18[3]; // [xsp+C0h] [xbp-C0h] BYREF _QWORD v19[3]; // [xsp+D8h] [xbp-A8h] BYREF __int64 v20[3]; // [xsp+F0h] [xbp-90h] BYREF __int64 v21[3]; // [xsp+108h] [xbp-78h] BYREF _BYTE v22[24]; // [xsp+120h] [xbp-60h] BYREF _BYTE v23[24]; // [xsp+138h] [xbp-48h] BYREF _BYTE v24[24]; // [xsp+150h] [xbp-30h] BYREF __int64 v25; // [xsp+168h] [xbp-18h] // 一堆变量定义 先忽略 v25 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40); // 数组声明 sub_16370(v24); // GetStringUTFChars 转化c的字符串 StringUTFChars = _JNIEnv::GetStringUTFChars((__int64)a1, a3, 0LL); // char数组转为string 后存入v23 std::string::basic_string&lt;decltype(nullptr)&gt;(v23, StringUTFChars); // 存放输入 sub_16394((__int64)v24, (__int64)v23); // 问了一下通义。说是析构函数 用于销毁对象并释放对象所占用的资源 那么说明 v23被删掉了 std::string::~string(v23); // 同上 把 9fdLnciVh4FxQbri 转为string 并放入v22 std::string::basic_string&lt;decltype(nullptr)&gt;(v22, &quot;9fdLnciVh4FxQbri&quot;); sub_16394((__int64)v24, (__int64)v22); // 同上操作 std::string::~string(v22); std::to_string(v21, (std::__ndk1 *)a4, v4); sub_16394((__int64)v24, (__int64)v21); // 同上操作 std::string::~string(v21); // 获取时间 v9 = (std::__ndk1 *)time(0LL); // 转化 字符串 std::to_string(v20, v9, v5); sub_1645C(v24, v20); // join拼接将v24内容拼接 存入 v18 44LL 其实代表了44 而44的ascii值为 , join(v18, v24, 44LL); // 进行sha1 计算 sha1(v19, v18); // 删除 v18 std::string::~string(v18); // 新数组声明 sub_16370(v17); // 数组存放 v19 sub_1645C(v17, v19); // 数组存放 v20 sub_1645C(v17, v20); // 拼接 v17 ,拼接 存入v6 join(v16, v17, 44LL); std::string::basic_string(v14, v16); // base64 存入v15 b64encode(v15, v14); //删除v14 std::string::~string(v14); // v15转化char数组 v8 = (char *)sub_165EC(v15); // 转化 NewStringUTF v7 = _JNIEnv::NewStringUTF(a1, v8); // 删除 其他值 std::string::~string(v15); std::string::~string(v16); sub_16610(v17); std::string::~string(v19); std::string::~string(v20); sub_16610(v24); _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)); // 返回v7 return v7; } 其实大概就知道了， 整体代码在进行参数拼接和一个 sha1 的加密 /api/movie,9fdLnciVh4FxQbri,0,1724821893 –SHA1–&gt; f4a5967ca35651c43f1bd5763980c907f914ef95 与上文一样，最后再把时间戳给加上。 结果是一致的。 如果想深度探索,可以在利用 unidbg 跑一下结果 。 附上代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.spdiercenter; import com.alibaba.fastjson.util.IOUtils; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.Module; import com.github.unidbg.arm.backend.Unicorn2Factory; import com.github.unidbg.debugger.Debugger; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.DalvikModule; import com.github.unidbg.linux.android.dvm.DvmClass; import com.github.unidbg.linux.android.dvm.StringObject; import com.github.unidbg.linux.android.dvm.VM; import com.github.unidbg.memory.Memory; import java.io.File; public class SpcUtil { private final AndroidEmulator emulator; private final VM vm; private final Module module; private final DvmClass NativeHelper; private final boolean logging; SpcUtil(boolean logging) { this.logging = logging; emulator = AndroidEmulatorBuilder.for64Bit() .setProcessName(&quot;com.goldze.mvvmhabit&quot;) .addBackendFactory(new Unicorn2Factory(true)) .build(); // 创建模拟器实例，要模拟32位或者64位，在这里区分 final Memory memory = emulator.getMemory(); // 模拟器的内存操作接口 memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析 vm = emulator.createDalvikVM(); // 创建Android虚拟机 vm.setVerbose(logging); // 设置是否打印Jni调用细节 DalvikModule dm = vm.loadLibrary(new File(&quot;/Users/jiangxia/unidbg/apks/tujia/libnative.so&quot;), false); // 加载libttEncrypt.so到unicorn虚拟内存，加载成功以后会默认调用init_array等函数 dm.callJNI_OnLoad(emulator); // 手动执行JNI_OnLoad函数 module = dm.getModule(); // 加载好的libttEncrypt.so对应为一个模块 NativeHelper = vm.resolveClass(&quot;com/goldze/mvvmhabit/utils/NativeUtils&quot;);//加载类 } void destroy() { IOUtils.close(emulator); if (logging) { System.out.println(&quot;destroy&quot;); } } public void hooksha1() { Debugger MyDbg = emulator.attach(); // MyDbg.addBreakPoint(module.base + 0xC18); //断点地址 // MyDbg.addBreakPoint(module.base + 0x15F38); //断点地址 // MyDbg.addBreakPoint(module.base + 0x15430); //断点地址 // MyDbg.addBreakPoint(module.base + 0x17F1C); //断点地址 MyDbg.addBreakPoint(module.base + 0x15B9C); //断点地址 } public static void main(String[] args) throws Exception { SpcUtil test = new SpcUtil(true); test.hooksha1(); test.callFunc(); test.destroy(); } void callFunc() { String data = &quot;/api/movie&quot;; int p2 = 0; StringObject stringObject = NativeHelper.callStaticJniMethodObject(emulator, &quot;encrypt(Ljava/lang/String;I)Ljava/lang/String;&quot;, data, p2); System.out.println(stringObject); } } 代码整合就不写了，因为可能是太久了，app 中的数据都不加载了，我们分析得到的结果一直就够了。 末尾继续努力吧，有机会写一下易盾的空间推理。","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"360点选识别","slug":"验证码识别/验证码识别","date":"2024-08-24T08:08:48.000Z","updated":"2024-08-28T06:20:13.527Z","comments":true,"path":"2024/08/24/验证码识别/验证码识别/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/08/24/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/","excerpt":"","text":"360 点选实战(yolvo8+孪生)过程我们使用 python 脚本 爬取保存大概 100 多张图片即可，放在本地文件夹下。接着使用X-AnyLabeling 进行数据标注。主要注意的是需要导出中转为 yolo 格式，这样的话可以自动转为 yolo 可识别的 txt 文件接下来我们打标就可，因为是做孪生，所以我们不需要详细分类，给每个标签打上固定的标签即可，我这里是 labels。 依次标注即可，360 这个并没有太多的图片，基本都是相同种类重复的偏多，就是改个字体。打完标之后我们就可以利用一个脚本 进行格式转化了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189# -*- coding: utf-8 -*- import json import os import random import shutil def json2yolo(json_folder, class_dic): &quot;&quot;&quot;讲labelme的json文件转成txt文件 {&quot;notch&quot;: &#39;0&#39;}&quot;&quot;&quot; file_list = os.listdir(json_folder) txt_folder = os.path.dirname(json_folder) + &quot;\\labels_txt&quot; if not os.path.exists(txt_folder): os.makedirs(txt_folder) json_file_list = [x for x in file_list if &quot;.json&quot; in x] # 获取所有json文件的路径 for p in json_file_list: json_file = os.path.join(json_folder, p) with open(json_file, encoding=&#39;utf-8&#39;) as f: data = json.loads(f.read()) img_w = data[&quot;imageWidth&quot;] # 获取json文件里图片的宽高 img_h = data[&quot;imageHeight&quot;] all_line = &#39;&#39; for i in data[&quot;shapes&quot;]: # 归一化坐标点。并得到cx,cy,w,h [[x1, y1], [x2, y2]] = i[&#39;points&#39;] x1, x2 = x1 / img_w, x2 / img_w y1, y2 = y1 / img_h, y2 / img_h cx = (x1 + x2) / 2 cy = (y1 + y2) / 2 w = abs(x2 - x1) h = abs(y2 - y1) # 将数据组装成yolo格式 line = f&quot;%s %.4f %.4f %.4f %.4f\\n&quot; % (class_dic[i[&#39;label&#39;]], cx, cy, w, h) # 生成txt文件里每行的内容 all_line += line # print(all_line) txt_file = os.path.join(txt_folder, p.replace(&#39;json&#39;, &#39;txt&#39;)) with open(txt_file, &#39;w&#39;, encoding=&#39;utf-8&#39;) as fh: fh.write(all_line) # json2yolo(r&#39;D:\\Web_Decryption\\SEASON\\0527\\test&#39;, {&quot;殊&quot;:&quot;0&quot;,&quot;乡&quot;:&quot;1&quot;,&quot;趋&quot;:&quot;2&quot;,}) def shape2id(json_folder): classes2id = {} classes_all = set() num = 0 jsons = os.listdir(json_folder) for i in jsons: json_path = os.path.join(json_folder, i) with open(json_path, &#39;r&#39;, encoding=&quot;utf-8&quot;) as f: json_data = json.load(f) # print(json_data[&#39;shapes&#39;]) for j in json_data[&#39;shapes&#39;]: if j[&#39;label&#39;] not in classes2id: classes2id[j[&#39;label&#39;]] = num num += 1 classes_all.add(j[&#39;label&#39;]) print(classes2id) print(&quot;所有分类&quot;, classes_all) return classes2id # shape2id(r&#39;D:\\day_soft\\Labelme\\custom_model\\lably&#39;) def split_images_floder(img_dir, label_dir, img_suffix=&#39;.png&#39;): &quot;&quot;&quot; 将数据集划分为训练集，验证集，测试集 &quot;&quot;&quot; # 1.确定原图片数据集路径 datasetimg_dir = img_dir # 确定原label数据集路径 datasetlabel_dir = label_dir # 2.确定数据集划分后保存的路径 _f = os.path.dirname(img_dir) split_dir = os.path.join(_f, &quot;dataset&quot;) train_dir = os.path.join(split_dir, &quot;train&quot;) valid_dir = os.path.join(split_dir, &quot;valid&quot;) test_dir = os.path.join(split_dir, &quot;test&quot;) dir_list = [train_dir, valid_dir, test_dir] image_label = [&#39;images&#39;, &#39;labels&#39;] for i in range(len(dir_list)): for j in range(len(image_label)): new_dir = os.path.join(dir_list[i], image_label[j]) if not os.path.exists(new_dir): os.makedirs(new_dir) # 3.确定将数据集划分为训练集，验证集，测试集的比例 train_pct = 0.9 valid_pct = 0.1 test_pct = 0 # 4.划分 imgs = os.listdir(datasetimg_dir) # 展示目标文件夹下所有的文件名 imgs = list(filter(lambda x: x.endswith(img_suffix), imgs)) # 取到所有以.png结尾的文件，如果改了图片格式，这里需要修改 random.shuffle(imgs) # 乱序路径 img_count = len(imgs) # 计算图片数量 train_point = int(img_count * train_pct) # 0:train_pct valid_point = int(img_count * (train_pct + valid_pct)) # train_pct:valid_pct for i in range(img_count): if i &lt; train_point: # 保存0-train_point的图片到训练集 out_dir = os.path.join(train_dir, &#39;images&#39;) label_out_dir = os.path.join(train_dir, &#39;labels&#39;) elif i &lt; valid_point: # 保存train_point-valid_point的图片到验证集 out_dir = os.path.join(valid_dir, &#39;images&#39;) label_out_dir = os.path.join(valid_dir, &#39;labels&#39;) else: # 保存test_point-结束的图片到测试集 out_dir = os.path.join(test_dir, &#39;images&#39;) label_out_dir = os.path.join(test_dir, &#39;labels&#39;) target_path = os.path.join(out_dir, imgs[i]) # 指定目标保存路径 src_path = os.path.join(datasetimg_dir, imgs[i]) # 指定目标原图像路径 label_target_path = os.path.join(label_out_dir, imgs[i][0:-4] + &#39;.txt&#39;) label_src_path = os.path.join(datasetlabel_dir, imgs[i][0:-4] + &#39;.txt&#39;) shutil.copy(src_path, target_path) # 复制图片 shutil.copy(label_src_path, label_target_path) # 复制txt print(&#39;train:{}, valid:{}, test:{}&#39;.format(train_point, valid_point - train_point, img_count - valid_point)) #split_images_floder(r&quot;C:\\Users\\24572\\PycharmProjects\\pythonProject\\360click\\images&quot;, r&quot;C:\\Users\\24572\\PycharmProjects\\pythonProject\\360click\\labels&quot;) def make_yolo_yaml(yaml_name, image_dir, class_names): &quot;&quot;&quot;生成yolo格式的yaml文件&quot;&quot;&quot; if not os.path.exists(yaml_name): os.makedirs(yaml_name) nums = len(class_names) # 生成数据集配置.yaml with open(yaml_name, &quot;w&quot;, encoding=&#39;utf-8&#39;) as f: f.write(f&quot;train: {image_dir}/train/images\\n&quot;) f.write(f&quot;val: {image_dir}/valid/images\\n&quot;) f.write(f&quot;test: {image_dir}/test/images\\n&quot;) f.write(&quot;\\n&quot;) f.write(f&quot;nc: {nums}\\n&quot;) f.write(f&quot;names: {class_names}\\n&quot;) make_yolo_yaml(r&quot;C:\\Users\\24572\\PycharmProjects\\pythonProject\\360click\\font.yaml&quot;, r&#39;C:\\Users\\24572\\PycharmProjects\\pythonProject\\360click\\dataset&#39;, [&quot;labels&quot;]) def create_valid_test_folder(image_dir, labels_dir, img_suffix=&#39;.jpg&#39;): &quot;&quot;&quot; :param image_dir: D:\\Yzmtrain\\yzmdata\\dyclick_524\\images_all :param labels_dir: D:\\Yzmtrain\\yzmdata\\dyclick_524\\labels_all :param img_suffix: :return: &quot;&quot;&quot; _folder = os.path.dirname(image_dir) for dirs in [&#39;train/images&#39;, &#39;train/labels&#39;, &#39;valid/images&#39;, &#39;valid/labels&#39;, &#39;test/images&#39;, &#39;test/labels&#39;]: try: os.makedirs(os.path.join(image_dir, dirs)) except FileExistsError: print(f&#39;{dirs} 目录已存在&#39;) image_file_list = os.listdir(image_dir) total_num = len(image_file_list) train_num = int((total_num-10)/7) valid_num = total_num - 10 - train_num for img_name in image_file_list[:10]: json_name = img_name.replace(img_suffix, &quot;.json&quot;) img_src = os.path.join(image_dir, img_name) dst_images = os.path.join(f&quot;{_folder}/test/images&quot;, img_name) os.rename(img_src, dst_images) labels_src = os.path.join(labels_dir, json_name) dst_labels = os.path.join(f&quot;{_folder}/test/labels&quot;, json_name) os.rename(labels_src, dst_labels) def rename_file(): aa_all = {} json_folder = &quot;D:\\Yzmtrain\\yzmdata\\hanzi_1\\hanzi\\hanzi\\js11&quot; file_list = os.listdir(json_folder) json_file_list = [x for x in file_list if &quot;.json&quot; in x] # 获取所有json文件的路径 for p in json_file_list: json_file = os.path.join(json_folder, p) image_file = json_file.replace(&quot;\\js11&quot;, &#39;&#39;).replace(&quot;json&quot;, &quot;jpg&quot;) with open(json_file, encoding=&#39;utf-8&#39;) as f: data = json.loads(f.read()) print(json_file, image_file) print(p, data[&#39;shapes&#39;][0][&#39;label&#39;]) aa_all[p] = f&quot;{data[&#39;shapes&#39;][0][&#39;label&#39;]}_{p[2:]}&quot; os.rename(json_file, f&quot;D:\\Yzmtrain\\yzmdata\\hanzi_1\\hanzi\\hanzi\\js11\\\\{data[&#39;shapes&#39;][0][&#39;label&#39;]}_{p[2:]}&quot;) os.rename(image_file, f&quot;D:\\Yzmtrain\\yzmdata\\hanzi_1\\hanzi\\hanzi\\\\{data[&#39;shapes&#39;][0][&#39;label&#39;]}_{p[2:]}&quot;.replace(&quot;json&quot;, &quot;jpg&quot;)) print(aa_all) # rename_file() # _folder = &quot;D:\\Yzmtrain\\yzmdata\\chinese&quot; # file_list = os.listdir(_folder) # json_file_list = [x for x in file_list if &quot;.json&quot; in x] # 获取所有json文件的路径 # for p in json_file_list: # json_file = os.path.join(_folder, p) # os.rename(json_file, f&quot;D:\\Yzmtrain\\yzmdata\\chinese_json\\\\{p}&quot;) 运行 split_images_floder 之后本地就会生成 一些文件夹，其中存放着划分的验证机和数据集之后创建一个 font.yaml 的文件 在运行 make_yolo_yaml 就生成了支持 yolov8 训练的配置文件。以上都大功告成之后，我们就可以开始进行训练了 123from ultralytics import YOLO model = YOLO(&quot;yolov8n.pt&quot;) # load a pretrained model (recommended for training) results = model.train(data=&quot;font.yaml&quot;, epochs=200, cache=True, imgsz=320, batch=16, workers=0, device=&#39;cuda&#39;) 之后我们会在当前 runs&#x2F;detect&#x2F;train&#x2F;weights 得到一个 best.pt 文件 这就是我们后面需要识别和切割的模型了我们利用Siamese-pytorch 我们本地下载 GitHub 中提供的模型，并把它放入 model_data 中，然后我们运行 predict.py 文件 来测试环境是否正确。 如果没问题那么就可以开始我们正式训练了.首先我们来明确一下思路。 需要先获得一张图片 之后要利用 yolov8 进行识别切割，并保存在一个文件夹中 我们要遍历切割后的文件夹，并且以某一张图片来作为基准，与其他对比。同时获取裁切后的坐标，方便后续找到不同图片时也能得到对应坐标。 情况 1:对比后找到其他图片为相似度最小的一张 情况 2:当前这张要对比的图片与其他 4 张都不同，是特立独行的图片 4.提交验证，有加密处理加密，有验证提交验证数据包。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177import json import random import time import execjs from PIL import Image from ultralytics import YOLO from siamese import Siamese import cv2 import numpy as np import os import requests token = &#39;e7e3456c9521de075c0ed00a7d6d7480&#39; headers = { &quot;accept&quot;: &quot;*/*&quot;, &quot;accept-language&quot;: &quot;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&quot;, &quot;cache-control&quot;: &quot;no-cache&quot;, &quot;pragma&quot;: &quot;no-cache&quot;, &quot;referer&quot;: &quot;https://sqhd.u.360.cn/&quot;, &quot;sec-ch-ua&quot;: &quot;\\&quot;Not)A;Brand\\&quot;;v=\\&quot;99\\&quot;, \\&quot;Microsoft Edge\\&quot;;v=\\&quot;127\\&quot;, \\&quot;Chromium\\&quot;;v=\\&quot;127\\&quot;&quot;, &quot;sec-ch-ua-mobile&quot;: &quot;?0&quot;, &quot;sec-ch-ua-platform&quot;: &quot;\\&quot;Windows\\&quot;&quot;, &quot;sec-fetch-dest&quot;: &quot;script&quot;, &quot;sec-fetch-mode&quot;: &quot;no-cors&quot;, &quot;sec-fetch-site&quot;: &quot;same-site&quot;, &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36 Edg/127.0.0.0&quot; } cookies = { &quot;__huid&quot;: &quot;11xEyO13c+M4dgY6TiYNLPb9LRVgaku/GXVMp/qF0GMNQ=&quot;, &quot;__guid&quot;: &quot;230272478.3358358338768799744.1704856402001.2004&quot;, &quot;__NS_Q&quot;: &quot;u%3Dyv083024%26n%3D%26le%3D%26m%3DZGp3WGWOWGWOWGWOWGWOWGWOZGL4%26qid%3D3403077592%26im%3D1_t01923d359dad425928%26src%3Dpcw_quake%26t%3D1&quot;, &quot;Q&quot;: &quot;u%3Dyv083024%26n%3D%26le%3D%26m%3DZGp3WGWOWGWOWGWOWGWOWGWOZGL4%26qid%3D3403077592%26im%3D1_t01923d359dad425928%26src%3Dpcw_quake%26t%3D1&quot;, &quot;__DC_gid&quot;: &quot;208211024.767422413.1715657472373.1715657472383.2&quot;, &quot;T&quot;: &quot;s%3Dfe966e73df014d7fc952331d9cd492cb%26t%3D1715925046%26lm%3D%26lf%3D4%26sk%3D6d22cff2c2004dc594d8a9cd5674ca07%26mt%3D1715925046%26rc%3D%26v%3D2.0%26a%3D1&quot;, &quot;__NS_T&quot;: &quot;s%3Dfe966e73df014d7fc952331d9cd492cb%26t%3D1715925046%26lm%3D%26lf%3D4%26sk%3D6d22cff2c2004dc594d8a9cd5674ca07%26mt%3D1715925046%26rc%3D%26v%3D2.0%26a%3D1&quot; } # 获取验证码图片并且保存图片和一些提交验证的参数。 def get(): url = &quot;https://captcha.bpd.360.cn/v1/get&quot; params = { &quot;appid&quot;: &quot;LS3yVZANuLCqvFn1IWNGVNeC37ExAbuL&quot;, &quot;token&quot;: token, &quot;ty&quot;: &quot;3&quot;, } response = requests.get(url, headers=headers, cookies=cookies, params=params).json() print(response) pic_url = response[&quot;data&quot;][&quot;pic&quot;][&quot;bg&quot;] ftoken = response[&quot;data&quot;][&quot;ftoken&quot;] pic_ = requests.get(pic_url,headers=headers) with open(f&quot;./img/{int(time.time()*1000)}.png&quot;,&#39;wb&#39;) as f: f.write(pic_.content) print(&quot;完成&quot;) return pic_url,ftoken pic_url,ftoken = get() # 加载YOLO模型 model = YOLO(&#39;best.pt&#39;) # 利用YOLO进行 指定坐标裁切 def cai_save(img_big): results = model.predict(img_big) img_big_cai = [] # 裁剪图片并保存在列表中 center_coordinates = {} for idx, box in enumerate(results[0].boxes.xyxy): box = list(map(int, box)) img_c = img_big[box[1]:box[3], box[0]:box[2]] img_big_cai.append(img_c) center_x = int((box[0] + box[2]) / 2) center_y = int((box[1] + box[3]) / 2) #获取裁切后的坐标 center_coordinates[f&#39;qie_{idx + 1}&#39;] = {&#39;center_x&#39;: center_x, &#39;center_y&#39;: center_y} # 保存裁剪后的图片 folder_path = &#39;./cai_big_images&#39; if not os.path.exists(folder_path): os.makedirs(folder_path) for idx, img_array in enumerate(img_big_cai, start=1): # 生成文件名 filename = f&quot;qie_{idx}.jpg&quot; filepath = os.path.join(folder_path, filename) # 保存图片 cv2.imwrite(filepath, img_array) return center_coordinates dir_path = r&#39;E:\\Siamese-pytorch\\img&#39; files = os.listdir(dir_path) #遍历目录下的图片文件 print(files) for file in files: img = cv2.imread(os.path.join(dir_path, file)) center_coordinates = cai_save(img) print(center_coordinates) #输出坐标 print(&quot;全部切分完成，开始孪生对比&quot;) # 创建一个 Siamese 类的实例 model = Siamese() def compare_with_reference(folder_path, reference_filename): min_similarity = float(&#39;inf&#39;) # 存储与参考图片相比最不相似的图片的相似度 unique_image_filename = None # 存储最不相似的图片文件名 reference_image = Image.open(os.path.join(folder_path, reference_filename)) for filename in os.listdir(folder_path): if filename.endswith(&quot;.jpg&quot;) or filename.endswith(&quot;.jpeg&quot;): if filename == reference_filename: continue # 跳过参考图片本身 # 加载图片 image_path = os.path.join(folder_path, filename) image = Image.open(image_path) # 使用模型计算相似度概率 孪生识别 probability = model.detect_image(reference_image, image) probability_value = probability.item() # 如果当前图片的相似度低于之前记录的最低相似度，则更新 if probability_value &lt; min_similarity: min_similarity = probability_value unique_image_filename = filename # 返回最不相似的图片文件名及其相似度 return unique_image_filename, min_similarity folder_path = r&quot;E:\\Siamese-pytorch\\cai_big_images&quot; #裁切后图片位置 unique_image_filename, min_similarity = compare_with_reference(folder_path, &#39;qie_2.jpg&#39;) #打开参考图片 qie_2.jpg if unique_image_filename is not None: unique_image_key = unique_image_filename.replace(&quot;.jpg&quot;,&quot;&quot;) unique_image_coordinates = center_coordinates.get(unique_image_key,None) print(f&quot;特立独行的图片是 {unique_image_filename}，相似度为 {min_similarity},中心坐标为: {unique_image_coordinates}&quot;) # # 显示特立独行的图片 # unique_image_path = os.path.join(folder_path, unique_image_filename) # unique_image = cv2.imread(unique_image_path) # cv2.imshow(&#39;Unique Image&#39;, unique_image) # cv2.waitKey(0) # cv2.destroyAllWindows() print(unique_image_coordinates) #####网站加密的轨迹坐标处理 x = unique_image_coordinates[&#39;center_x&#39;] y = unique_image_coordinates[&#39;center_y&#39;] final_list = [] print(&#39;x&#39;, x) print(&#39;y&#39;, y) # 网页实际缩放了图片 比例是1/2 所以要乘0.5 对应网页 entry = { &quot;x&quot;: int(x * 0.5), &quot;y&quot;: int(y * 0.5), &quot;t&quot;: int(time.time() * 1000) + random.randint(0, 150), # 固定时间戳 &quot;type&quot;: &quot;mousedown&quot; # 固定操作类型 } final_list = [entry] guiji = json.dumps(final_list) print(guiji) # aes加密 d = execjs.compile(open(&#39;./1.js&#39;, &#39;r&#39;, encoding=&quot;utf-8&quot;).read()).call(&#39;get_d&#39;, guiji) print(d) #提交验证 url = &quot;https://captcha.bpd.360.cn/v1/verify&quot; params = { &quot;appid&quot;: &quot;LS3yVZANuLCqvFn1IWNGVNeC37ExAbuL&quot;, &quot;token&quot;: token, &quot;ftoken&quot;: ftoken, &quot;d&quot;: d, &quot;scale&quot;: &quot;0.5&quot;, &quot;ty&quot;: &quot;3&quot;, &quot;src&quot;: &quot;&quot;, &quot;imgUrl&quot;: pic_url, } response = requests.get(url, headers=headers, cookies=cookies, params=params) print(response.text) 结果验证到此完结。 通过了还是可以的","categories":[{"name":"验证码识别","slug":"验证码识别","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"}],"tags":[]},{"title":"安居客参数分析","slug":"逆向/安居客参数分析","date":"2024-08-23T05:52:22.000Z","updated":"2025-03-07T02:38:25.700Z","comments":true,"path":"2024/08/23/逆向/安居客参数分析/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/08/23/%E9%80%86%E5%90%91/%E5%AE%89%E5%B1%85%E5%AE%A2%E5%8F%82%E6%95%B0%E5%88%86%E6%9E%90/","excerpt":"","text":"安居客参数分析前言手机里之前装过很多杂乱软件，最近闲来无事，又在学习 app 的东西，翻来翻来就找到了这个找房软件，于是想着分析一下，在此记录一下过程，也算是成长过程的小经历了，话不多开，分析开始。 请求分析 这个抓包软件是 Proxyman，Charles 在 mac 我目前还没找到好的汉化的，英文的用的也不是很舒服，所以就用 Proxyman 代替了，我们看到了加密参数特别显眼的就是nsign和 nsign_uuid 应该是和nsign有关和get_md5&#96; 参数分析做 app 逆向第一步肯定就是反编译了，不过在此之前我们还需要查看 app 是否加固，否则没办法得到大概的源代码，我们用 appmsg 进行查看。 ​ 很好啊，没有加固，我们直接 jadx 进行反编译即可。 nsign 进入了 SignUtil.c 的方法，而 SignUtil.c 则在函数中调用了一个 getSign0 的 native 方法。 ​ 我们直接打开 ida 啊，去找一下 SignUtil 这个 so 文件 ​ 是个静态注册，而且代码也没什么混淆，还是很利于我们分析的，其实我们也可以trace_natives这个 ida 插件，就能获取 SO 代码段中所有函数的偏移地址，再使用 frida-trace 批量 trace so 函数的调用。(由于 mac 下暂无高版本的 ida pro,所以我此处用 Windows 的 ida7.7 演示.) 图没截全，我们根据最开始的 sub_18f0 找过去，我们先静态分析一下代码, 发现 get_sign 这个函数比较亮眼，而我们刚才 trace 的过程中也有这个函数的调用，所以我们继续反编译分析查看 1qsort(v11, v9, 24LL, sub_185C); 看到一个 sub_185c 这个函数的调用，其实我们大概能根据 qsort 猜出来，他是根据全面的 hook 的请求参数来进行一个 sort 排序， 在下文我们能看到这个”bcb2e93c6b527180099601a2dd8ef8b1”这个字符串，很大可能性是在下文的 SIGNMD5()这个函数中的进行 md5 加盐的操作 我们进入 SIGNMD5 函数查看 已经很像 Md5 的操作，还需经进入 sub_C18 查看 已经很明显看到 这个是 md5 加密中的 k 表的第一个 但是下文的结构也不是很像，所以我们具体要 hook 一下，然后手动 md5 加密看看，是否为标准的 md5 加密。","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"某东4.7jsvmp 算法还原","slug":"逆向/某东4-7jsvmp-算法还原","date":"2024-08-23T04:44:22.000Z","updated":"2024-09-21T11:10:22.885Z","comments":true,"path":"2024/08/23/逆向/某东4-7jsvmp-算法还原/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/08/23/%E9%80%86%E5%90%91/%E6%9F%90%E4%B8%9C4-7jsvmp-%E7%AE%97%E6%B3%95%E8%BF%98%E5%8E%9F/","excerpt":"","text":"京东 h5st 4.7.4H5st以下参数皆为研究时随机参数 并不 是同一请求 全部参数 特别注意的是在 aes 加密过程中用的 fp 需要和第二段保持一致 否则将会请求失败。 12345678920240721134400770; 第一段 5t96nmyigzygygy9; 第二段 74f42; 第三段 tk03wbb161bb218ny47exhUsIoE3D7lHbxbZgTik7YqisIFvWjBTQG8XlY2fmxSJ5sec_Q95KVeW9RG8w227CEONjo52;第四段 f4a8befb0820e360d42ba0a7805b81e0; 第五段 新增一段 4.7; 第六段 1721532832275; 第七段 UOWRm8fD2k3wKIklaB5h58P7JQx1oXrg_gB7U7jVoEs1NiltSlNQddHgLqVLdjHSiXGLgu72eJ7n13kJgBCBIIHceQiv3eNMhgHk1ZUbAPT4josbXzPcT4mD-ZqTokNYpDn-IifpL1SQ_X7FmySgoTTmntIOskhmlQfn2MvsQZJE6JK80ykJk3DjWsqWSKWJyzA0_NsXY2m5NBWtpTOQ9rljTB8IWGrJR9R_aH5RLHnbpaoXOrXHhE1oJ9IZc9zRYaKSXjaFhRqhCdGqq4wW9GASnk6ddS2HYMMfOYfCLVCQkWp6f725741DXfhF94h2Kssd4eedjcIl5HIlyOlFvHsFRTmsnIOKqSLln_6hbg04svF3qgBbQVAKsqCnsVCuVTB0QCJ4pBu3aWHAKjuvyYyDwxL3E2UTOq5A8_dGSqEiSU1MrfZy--K3O56hREYguSt09mu3Rb6RtORJu8aBFo5n; 第八段 魔改aes 4b8b4c86155f61276e7a8df6ffc8dcdc 第九段 新增一段 第一段123456789101112//根据当前时间戳转换的 1721540640770 --&gt;20240721134400770 function formatTime(timestamp) { const date = new Date(timestamp); const year = date.getFullYear(); const month = (date.getMonth() + 1).toString().padStart(2, &quot;0&quot;); const day = date.getDate().toString().padStart(2, &quot;0&quot;); const hours = date.getHours().toString().padStart(2, &quot;0&quot;); const minutes = date.getMinutes().toString().padStart(2, &quot;0&quot;); const seconds = date.getSeconds().toString().padStart(2, &quot;0&quot;); const milliseconds = date.getMilliseconds().toString().padStart(3, &quot;0&quot;); return `${year}${month}${day}${hours}${minutes}${seconds}${milliseconds}`; } 第二段1234567891011121314151617//生成的 fingerprint e.generateVisitKey = function () { let t = &quot;1uct6d0jhq&quot;; //改变了 还没找到 let o = k(t, 5); let i = y(); let c = _(t, o); let s = m({ size: i, num: c }) + o + m({ size: 16 - 5 - 1 - i, num: c }) + i; let u = s.split(&quot;&quot;); let l = u.slice(0, 15); let p = u.slice(15); let v = []; while (l.length &gt; 0) { v.push((35 - parseInt(l.pop(), 36)).toString(36)); } return v.concat(p).join(&quot;&quot;); }; 第三段1//appid, 每个接口都有一个对应的值 第四段1获取到的token 第五段 1234567891011121314151617181920212223242526272829//item.jd.com (function anonymous() { return function test(tk, fp, ts, ai, algo) { // ai 为73806 且为固定数 var rd = &quot;jr6qBP48qndB&quot;; var str = &quot;&quot;.concat(tk).concat(fp).concat(ts).concat(ai).concat(rd); return algo.HmacSHA256(str, tk); }; }); /* 在经过t.algo.HMAC 时候 自写了 init和ekey 函数 其中 init函数应该是初始化字符串 ekey函数操作是 tk03w8c3e1c3e18nXPECn0kkSU01SK7QBOZ6CnS2ONny98eulgMemppU2VFRzTrfjau4E0ZztEMdpNbOHSCRv8SclwgS 反转字符串---&gt;vmp操作后得到&#39;kn3* 这个字符串暂时不知道怎么来的 但多次测试是固定的(包括更换设备更换浏览器更换账号等) 应该和某个固定字符串有关 &#39;kn3*8c3e1c3e18nXPECn0kkSU01SK7QBOZ6CnS2ONny98eulgMemppU2VFRzTrfjau4E0ZztEMdpNbOHSCRv8SclwgS */ /* [sign] __makeSign, result:{ &quot;key&quot;: &quot;1146b5b7dd7d22e0a54dbc15b88e3d3af128bbf4d9a7202f70bd17f648619b19f4a7bea82ac734a3e9846ddfa77889c82ae195fa659aab5dafcd9f39d0ca997d&quot;, &quot;signStr&quot;: &quot;cf39e022791e801e8e14831caf9ce9ba&quot;, &quot;_stk&quot;: &quot;r,t&quot;, &quot;_ste&quot;: 1, &quot;h5st&quot;: &quot;20240724162804806;65i6tgyn9m5zzzi5;73806;tk03wb5891cc618nLyxfAEBtCpMCZjxBj2zClh3zmA66NEPAbCgNviddGCDhG71yVMBcjItUgiu_ZAc3Gywo8QbnjqWT;cf39e022791e801e8e14831caf9ce9ba;4.7;1721809684806;UOmmZVMpjhlF79xYgh738cOy_ODWEgb7Yup7dEol2JF27v4kqKSLKMqNG3pEHTFJRf-odLa1vnNCtjj9ElYBbCjkPbWYU7HJlGyhMiT-SHASJA-gEkuJTMM78rLGFZdgCbfMpt-sdfRCrw57yOVdgSiAf4q2r5igXFEmLeSWWXrlTdHAfIozsGdsOPp6_VL-ffPmbpCtne3f8eV94isG75oexYsT2BBJKhorpaTxIaUrc_pQDqu4JV3kSI7KkVVqCRyjBVi0M64P8BEq_eOzchggqqWSXPIYV0Lay933IbGUEiW62DNv6DQO_bjnmEauatShWIgckcVMADGRP0IUP2w6o_DL1BZHEVhWlt3rQEUEBluS6QH1to002ho4zGr6P-A80a6PXFzj0V2CWmsbxdtefFQBuzPcacrWVP2EapUUjYoXOrXHhE1oJ9IZc9zRYaKSXjaFhRqhCdGqq4wW9GASnk6ddS2HYMMfOYfCLVCQkWp6f725741DXfhF94h2Kssd4eedjcIl5HIlyOlFvHsFRTmsnIOKqSLln_6hbg04svF3qgBbQVAKsqCnsVCuVTB0QCJ4pBu3aWHAKjuvyYyDwxL3E2UTOq5A8_dGSqEiSU1MrfZy--K3O56hREYguSt09mu3Rb6RtORJu8aBFo5n;73b25807580cfabdd047818058c75e83&quot; } hmac 如sha256 他的操作就是 先经过上述的ekey反转字符串 当作为hmac的key 密文和md5大同小异 而密文就是 tk03wb5891cc618nLyxfAEBtCpMCZjxBj2zClh3zmA66NEPAbCgNviddGCDhG71yVMBcjItUgiu_ZAc3Gywo8QbnjqWT 65i6tgyn9m5zzzi5 20240724162804806 47 73806 AfUt6ACvKwFn7n5&lt;G* tk拼接第二段在拼接第一段拼接47拼接appid拼接algo中的rd值拼接salt盐7n5&lt;G*后续操作同下述操作*/ 1234567891011tk03wbb161bb218ny47exhUsIoE3D7lHbxbZgTik7YqisIFvWjBTQG8XlY2fmxSJ5sec_Q95KVeW9RG8w227CEONjo525t96nmyigzygygy9202407211509126964774f428egu1x3bttOY7n5&lt;G* ---md5-&gt; b8df766f084d15a71eb7422a2c999137 b8df766f084d15a71eb7422a2c999137appid:pc_home_page&amp;client:pc&amp;clientVersion:1.0.0&amp;functionId:getAlwaysBuyGoods&amp;t:1721545191402b8df766f084d15a71eb7422a2c9991377n5&lt;G* --&gt;md5-&gt; 810c4f5c06a1307bc27490e3ffe80fcf 总的来说 第五段的生成 是第四段token拼接第二段 在拼接第一段在拼接4774f428egu1x3bttOY加上salt值7n5&lt;G* 生成md5值后 按键值对大小拼接body中的appid和client和clientVersion和functionid和t,最后在拼接一下生成的md5值和salt值7n5&lt;G*生成的结果即为第五段结果 至于 4774f428egu1x3bttOY 怎么来的，还没能研究透彻，但多次测试发现是固定的，可能与个人账号有关。 algo:function test(tk,fp,ts,ai,algo){var rd=&#39;IuxIY6nBYZ8r&#39;;var str=&quot;&quot;.concat(tk).concat(fp).concat(ts).concat(ai).concat(rd);return algo.HmacMD5(str,tk);} 现在发现 47是固定的 而 74f42是appid即第三段 8egu1x3bttOY是algo中的盐 即rd的值 如果请求参数带body 则需要把body进行sha256加密 然后带入第五段流程加密 第六段1版本号 4.7 第七段1与第一段相关 为时间戳 第八段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134//aes加密 key =&#39;_M6Y?dvfN40VMF[X&#39;; iv =&#39;0102030405060708&#39;; //魔改了aes 自定义了几个方法用于base64的编码设置 v.Utils = { toWordArray: function(e) { for (var r = [], n = 0; n &lt; e.length; n++) r[n &gt;&gt;&gt; 2] |= e[n] &lt;&lt; 24 - n % 4 * 8; return t.lib.WordArray.create(r, e.length) }, fromWordArray: function(e) { for (var t = new Uint8Array(e.sigBytes), r = 0; r &lt; e.sigBytes; r++) t[r] = e.words[r &gt;&gt;&gt; 2] &gt;&gt;&gt; 24 - r % 4 * 8 &amp; 255; return t } }; //一段jsvmp _append: function(e) { for (var t, r, n = c, a = i, o = [], l = 0; ; ) switch (a[l++]) { case 6: t = o[o.length - 1]; break; case 13: o.push(this); break; case 21: o.push(k); break; case 32: o.push(o[o.length - 1]); break; case 35: e = o[o.length - 1]; break; case 36: o[o.length - 2][s[a[l++]]] = o[o.length - 1], o[o.length - 2] = o[o.length - 1], o.length--; break; case 41: return; case 45: o.push(a[l++]); break; case 49: r = o.pop(), o[o.length - 1] += r; break; case 57: o.push(e); break; case 60: o.push(null); break; case 66: o[o.length - 1] = o[o.length - 1][s[a[l++]]]; break; case 67: o.push(t); break; case 69: o[o.length - 1] = Dg(o[o.length - 1]); break; case 72: o.pop(); break; case 73: o[o.length - 1] ? (++l, --o.length) : l += a[l]; break; case 75: o.push(o[o.length - 1]), o[o.length - 2] = o[o.length - 2][s[a[l++]]]; break; case 80: r = o.pop(), o[o.length - 1] = o[o.length - 1] == r; break; case 90: null != o[o.length - 2] ? (o[o.length - 3] = n.call(o[o.length - 3], o[o.length - 2], o[o.length - 1]), o.length -= 2) : (r = o[o.length - 3], o[o.length - 3] = r(o[o.length - 1]), o.length -= 2); break; case 95: o.push(u) } }, /*我们插装发现 他翻转了密钥 X[FMV04Nfvd?Y6M_ 其实这个aes整体并没做太大的魔改，只是把密钥给反转了而已，算法是原生的aes 主要魔改了base64算法 才使其加密的结果不同*/ //魔改base64算法 我们把所有运算符的操作给打上日志点，根据规律慢慢还原。 encode: function (t) { let r = e.enc.Utils.fromWordArray(t) let array = new Array(0) let n = array.slice.apply(r) let a = new Array(0) Array.prototype.push.apply(a, n) for (let o = 3 - a.length % 3, u = 0; u &lt; o; u++) { a.push(o) } let l = new Array(0) for (let i = a.length - 1; i &gt;= 0; i = i - 3) { a.slice(i - 2, i + 1) Array.prototype.push.apply(l, a.slice(i - 2, i + 1)) } let f = e.enc.Utils.toWordArray(l) let g = f.words let p = f.sigBytes let v = this._map1 f.clamp(f) let d = new Array(0) for (let b = 0; b &lt; p; b += 3) { let y = g[b &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - b * 8) &amp; 255 let k = g[(b + 1) &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (b + 1) * 8) &amp; 255 let m = g[(b + 2) &gt;&gt;&gt; 2] &gt;&gt;&gt; (24 - (b + 2) * 8) &amp; 255 let w = y &lt;&lt; 16 | k &lt;&lt; 8 | m for (let _ = 0; _ &lt; 4; _++) { if ((b + (_ * 0.75)) &lt; p) { d.push(v.charAt((w &gt;&gt;&gt; 6 * (3 - _) &amp; 63))) } } } let x = [] for (let j = 0; j &lt; d.length; j += 4) { x.push.apply(x, d.slice(j, j + 4).reverse()) } return x.join(&quot;&quot;) } 第九段12345678tk03wbb161bb218ny47exhUsIoE3D7lHbxbZgTik7YqisIFvWjBTQG8XlY2fmxSJ5sec_Q95KVeW9RG8w227CEONjo525t96nmyigzygygy9202407211245081744774f428egu1x3bttOY7n5&lt;G* --&gt; a1957d7fbdd8687cc8a075743aae865a a1957d7fbdd8687cc8a075743aae865aappid:pc_home_page&amp;functionId:getAlwaysBuyGoodsa1957d7fbdd8687cc8a075743aae865a7n5&lt;G* ---&gt;4b8b4c86155f61276e7a8df6ffc8dcdc 现在发现 47是固定的 而 74f42是appid即第三段 8egu1x3bttOY是algo中的盐 所以第8段的加密即为 第五段tk拼接第二段拼接第一段拼接4774f428egu1x3bttOY在拼接7n5&lt;G* 得到的md5值 md5值拼接body中的appid值在拼body中的functionId值在拼接md5值在拼接7n5&lt;G* 就得到了第9段的md5值 与第五段比较相近 但不用的在于 第八段之只用到了body中的appid和fucntionid这两个参数。 请求也是问题不大 一些坑点要想实现接口部署还需要部分细节修饰 algo12345对于algo 主要有一个expandParams的参数问题 他和第七段一样也是个aes。主要问题在于他的key不同于第七段 是 wm0!@w-s#ll1flo( 加密参数是 &#39;{\\n &quot;wc&quot;: 0,\\n &quot;wd&quot;: 0,\\n &quot;l&quot;: &quot;zh-CN&quot;,\\n &quot;ls&quot;: &quot;zh-CN,en,en-GB,en-US&quot;,\\n &quot;ml&quot;: 2,\\n &quot;pl&quot;: 2,\\n &quot;av&quot;: &quot;5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36 Edg/127.0.0.0&quot;,\\n &quot;ua&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36 Edg/127.0.0.0&quot;,\\n &quot;sua&quot;: &quot;Macintosh; Intel Mac OS X 10_15_7&quot;,\\n &quot;pp&quot;: {\\n &quot;p2&quot;: &quot;桥到船头自然沉9060&quot;\\n },\\n &quot;extend&quot;: {\\n &quot;wd&quot;: 0,\\n &quot;l&quot;: 0,\\n &quot;ls&quot;: 2,\\n &quot;wk&quot;: 0,\\n &quot;bu1&quot;: &quot;0.1.5&quot;,\\n &quot;bu2&quot;: 0,\\n &quot;bu3&quot;: 50,\\n &quot;bu4&quot;: 0,\\n &quot;bu5&quot;: 0,\\n &quot;bu6&quot;: 10\\n },\\n &quot;pp1&quot;: &quot;&quot;,\\n &quot;w&quot;: 1728,\\n &quot;h&quot;: 1117,\\n &quot;ow&quot;: 1728,\\n &quot;oh&quot;: 992,\\n &quot;url&quot;: &quot;https://paipai.m.jd.com/ppdbd/pages/detail/index?id=389626893&amp;cprice=47&amp;entryid=p0020003hd190531&amp;showhead=no&amp;entryid=p0020003hd190531&amp;scene=null&quot;,\\n &quot;og&quot;: &quot;https://paipai.m.jd.com&quot;,\\n &quot;pf&quot;: &quot;MacIntel&quot;,\\n &quot;pr&quot;: 2,\\n &quot;re&quot;: &quot;&quot;,\\n &quot;random&quot;: &quot;UhHAH4rSHNTC&quot;,\\n &quot;referer&quot;: &quot;&quot;,\\n &quot;v&quot;: &quot;h5_file_v4.7.4&quot;,\\n &quot;bu2&quot;: &quot; at https://storage.360buyimg.com/webcontainer/js_security_v3_0.1.5.js:3833:21&quot;,\\n &quot;canvas&quot;: &quot;fa3fabf83a3dc96ca518dcdec635e8d9&quot;,\\n &quot;webglFp&quot;: &quot;e3873b69ce54d5eb4893fad2d0592dda&quot;,\\n &quot;ccn&quot;: 14,\\n &quot;ai&quot;: &quot;86b9f&quot;,\\n &quot;fp&quot;: &quot;n5yi5yn5ytzg69i1&quot;\\n}&#39; 主要是ai 也就是appid 和fp 的处理问题就可以实现动态请求 random其实可以处理可以不处理","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"qqsign jsvmp算法还原","slug":"逆向/jsvmp-QQ音乐sign","date":"2024-08-23T04:40:22.000Z","updated":"2025-04-26T06:14:37.622Z","comments":true,"path":"2024/08/23/逆向/jsvmp-QQ音乐sign/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/08/23/%E9%80%86%E5%90%91/jsvmp-QQ%E9%9F%B3%E4%B9%90sign/","excerpt":"","text":"jsvmp-qq 音乐入口处直接搜 sign 打断点就好了 就定位到这个地方。 t.data 是加密的 params 进入 o，印入眼帘的则是 jsvmp 了 直接在 switch 处打上断电，猛梭就完事了。 输出的是 d 这个数组。 我们在上文中看到了一些 sha1 中的 4 轮运算的值 所以大胆猜测一下，他对我们的加密的字符串 params 做了 sha1 的加密操作，所以我们带到一个网站去加密然后验证一下 所以直接从 sha1 值第一处的往下分析。 有时间在讲吧，下面就是对 switch 插装 &#39;索引&#39;,n[g+1],g+1,&#39;值&#39;,console.log(d) call 地方打索引断点 。 贴出代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var aaa = [23, 14, 6, 36, 16, 40, 7, 19]; var bbb = [16, 1, 32, 12, 19, 27, 8, 5]; var ccc = [ 89, 39, 179, 150, 218, 82, 58, 252, 177, 52, 186, 123, 120, 64, 242, 133, 143, 161, 121, 179, ]; var string_to_num = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, }; var b64str = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;; var data_Sha1 = &quot;e3b7e88c5178c77fec1228baf2d8515f81e8809e&quot;.toUpperCase(); var stra = aaa .map((x) =&gt; { return data_Sha1.charAt(x); }) .join(&quot;&quot;); console.log(&quot;first&quot;, stra); var strb = bbb .map((x) =&gt; { return data_Sha1.charAt(x); }) .join(&quot;&quot;); console.log(&quot;last&quot;, strb); var result_arr = []; for (let i = 0; i &lt; 2 * ccc.length; i++) { var a1 = data_Sha1[i], a2 = data_Sha1[i + 1], b1 = string_to_num[a1], b2 = string_to_num[a2], c = ccc[i / 2], result = (b1 * 16) ^ b2 ^ c; result_arr.push(result); i++; } console.log(result_arr); console.log(result_arr.length); console.log(String.fromCharCode(...result_arr)); // /[+=]+$/ var str_medium = btoa(String.fromCharCode(...result_arr)).replace( /\\+|=+$/g, &quot;&quot; ); console.log(&quot;str_medium&quot;, str_medium.toLowerCase()); result_str = (&quot;zzc&quot; + stra + str_medium + strb).toLowerCase(); console.log(result_str);","categories":[{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-08-23T03:25:04.899Z","updated":"2024-08-23T03:25:04.899Z","comments":true,"path":"2024/08/23/hello-world/","permalink":"https://lpy30m.github.io/skuukzky.github.io/2024/08/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"验证码识别","slug":"验证码识别","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"},{"name":"逆向","slug":"逆向","permalink":"https://lpy30m.github.io/skuukzky.github.io/categories/%E9%80%86%E5%90%91/"}],"tags":[]}